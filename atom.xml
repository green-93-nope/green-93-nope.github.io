<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Summer is Green</title>
  
  <subtitle>a blog for writing and thinking</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://summerisgreen.com/"/>
  <updated>2020-02-07T04:45:54.338Z</updated>
  <id>http://summerisgreen.com/</id>
  
  <author>
    <name>Green</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ForkJoin中的窃取机制</title>
    <link href="http://summerisgreen.com/blog/2020-02-07-2020-02-03-forkjoin%E4%B8%AD%E7%9A%84%E7%AA%83%E5%8F%96%E6%9C%BA%E5%88%B6.html"/>
    <id>http://summerisgreen.com/blog/2020-02-07-2020-02-03-forkjoin中的窃取机制.html</id>
    <published>2020-02-06T16:00:00.000Z</published>
    <updated>2020-02-07T04:45:54.338Z</updated>
    
    <content type="html"><![CDATA[<p>从jdk1.7开始，jdk提供了ForkJoin相关工具类。与其他ExecutorService实现相比，其能够充分地利用多核优势来提高执行性能:</p><ol class="org-ol"><li>通过采用工作窃取算法，使得未被分配任务的工作线程也能从忙碌线程那窃取任务协助执行。</li><li>抽象ForkJoinTask提供了模板方法，以更好地支持将大任务拆分成小任务的分而治冶思想。</li></ol><p>本文基于jdk13的代码，来探讨下ForkJoin框架对于任务何时窃取，以及怎么窃取的问题。</p><div id="outline-container-orge49b0c0" class="outline-2"><h2 id="orge49b0c0">WorkQueue</h2><div class="outline-text-2" id="text-orge49b0c0"><p>ForkJoinPool中的WorkQueue被声明为数组形式，其通过区分外部提交和任务执行过程中产生的任务，优先执行提交任务所产生的子任务，从而优先完成已经开始执行的提交任务。该数组根据任务的来源区分为:</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="org-left"><col class="org-left"><col class="org-left"><col class="org-left"></colgroup><tbody><tr><td class="org-left">数组下标</td><td class="org-left">任务来源</td><td class="org-left">是否有绑定执行线程</td><td class="org-left">被窃取方式</td></tr><tr><td class="org-left">奇数</td><td class="org-left">ForkJoinTask产生的子任务</td><td class="org-left">绑定ForkJoinWorkerThread</td><td class="org-left">1.runWorker中的scan方法，2.awaitJoin方法窃取的队列任务</td></tr><tr><td class="org-left">偶数</td><td class="org-left">外部提交(非ForkJoinWorkerThread)</td><td class="org-left">否</td><td class="org-left">1.runWorker中的scan方法</td></tr></tbody></table><div class="org-src-container"><pre class="src src-java"><span style="color: #ce537a; font-weight: bold;">WorkQueue</span><span style="color: #4f97d7;">[]</span> <span style="color: #7590db;">workQueues</span>;              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">main registry</span></pre></div><p>从上面的表格可以看出，窃取分为工作线程主循环中的例程性窃取和join阻塞时辅助性窃取。</p></div></div><div id="outline-container-org89d01c3" class="outline-2"><h2 id="org89d01c3">主循环中的例程性窃取</h2><div class="outline-text-2" id="text-org89d01c3"><p>例程性的工作窃取是发生在工作线程主循环中调用链:forkJoinWorkerThread.run() -&gt; pool.runWorker(workQueue) -&gt; scan(workQueue, r)中的scan方法。其保证了优先完成已开始执行的ForkJoin任务，并且外部提交的任务在任务较多时不发生饥饿现象。</p><p>通过scan方法可以看出，其根据调用方runWorker方法所传入的随机数r开始，查找非空的窃取队列。找到后即调用当前forkJoinWorkerThread对应WorkQueue的topLevelExec，开始常规性运行过程。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #bc6ec5; font-weight: bold;">scan</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">WorkQueue</span> <span style="color: #7590db;">w</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">r</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">WorkQueue</span><span style="color: #bc6ec5;">[]</span> <span style="color: #7590db;">ws</span>; <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">n</span>;    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>ws = workQueues<span style="color: #2d9574;">)</span> != <span style="color: #a45bad;">null</span> &amp;&amp; <span style="color: #2d9574;">(</span>n = ws.length<span style="color: #2d9574;">)</span> &gt; <span style="color: #a45bad;">0</span> &amp;&amp; w != <span style="color: #a45bad;">null</span><span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>        <span style="color: #4f97d7; font-weight: bold;">for</span> <span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">m</span> = n - <span style="color: #a45bad;">1</span>, <span style="color: #7590db;">j</span> = r &amp; m;;<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            <span style="color: #ce537a; font-weight: bold;">WorkQueue</span> <span style="color: #7590db;">q</span>; <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">b</span>;            <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span><span style="color: #b1951d;">(</span>q = ws<span style="color: #4f97d7;">[</span>j<span style="color: #4f97d7;">]</span><span style="color: #b1951d;">)</span> != <span style="color: #a45bad;">null</span> &amp;&amp; q.top != <span style="color: #b1951d;">(</span>b = q.base<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span> <span style="color: #67b11d;">{</span>                <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">qid</span> = q.id;                <span style="color: #ce537a; font-weight: bold;">ForkJoinTask</span><span style="color: #b1951d;">&lt;</span>?<span style="color: #b1951d;">&gt;[]</span> <span style="color: #7590db;">a</span>; <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">cap</span>, <span style="color: #7590db;">k</span>; <span style="color: #ce537a; font-weight: bold;">ForkJoinTask</span><span style="color: #b1951d;">&lt;</span>?<span style="color: #b1951d;">&gt;</span> <span style="color: #7590db;">t</span>;                <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>a = q.array<span style="color: #4f97d7;">)</span> != <span style="color: #a45bad;">null</span> &amp;&amp; <span style="color: #4f97d7;">(</span>cap = a.length<span style="color: #4f97d7;">)</span> &gt; <span style="color: #a45bad;">0</span><span style="color: #b1951d;">)</span> <span style="color: #b1951d;">{</span>                    t = <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">ForkJoinTask</span><span style="color: #bc6ec5;">&lt;</span>?<span style="color: #bc6ec5;">&gt;</span><span style="color: #4f97d7;">)</span>QA.getAcquire<span style="color: #4f97d7;">(</span>a, k = <span style="color: #bc6ec5;">(</span>cap - <span style="color: #a45bad;">1</span><span style="color: #bc6ec5;">)</span> &amp; b<span style="color: #4f97d7;">)</span>;                    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #4f97d7;">(</span>q.base == b++ &amp;&amp; t != <span style="color: #a45bad;">null</span> &amp;&amp;                        QA.compareAndSet<span style="color: #bc6ec5;">(</span>a, k, t, <span style="color: #a45bad;">null</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>                        q.base = b;                        w.source = qid;                        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>a<span style="color: #2d9574;">[</span><span style="color: #9cb6ad;">(</span>cap - <span style="color: #a45bad;">1</span><span style="color: #9cb6ad;">)</span> &amp; b<span style="color: #2d9574;">]</span> != <span style="color: #a45bad;">null</span><span style="color: #bc6ec5;">)</span>                            signalWork<span style="color: #bc6ec5;">(</span>q<span style="color: #bc6ec5;">)</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">help signal if more tasks</span>                        w.topLevelExec<span style="color: #bc6ec5;">(</span>t, q,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">random fairness bound</span>                                       <span style="color: #2d9574;">(</span>r | <span style="color: #9cb6ad;">(</span><span style="color: #a45bad;">1</span> &lt;&lt; TOP_BOUND_SHIFT<span style="color: #9cb6ad;">)</span><span style="color: #2d9574;">)</span> &amp; SMASK<span style="color: #bc6ec5;">)</span>;                    <span style="color: #4f97d7;">}</span>                <span style="color: #b1951d;">}</span>                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;            <span style="color: #67b11d;">}</span>            <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>--n &gt; <span style="color: #a45bad;">0</span><span style="color: #67b11d;">)</span>                j = <span style="color: #67b11d;">(</span>j + <span style="color: #a45bad;">1</span><span style="color: #67b11d;">)</span> &amp; m;            <span style="color: #4f97d7; font-weight: bold;">else</span>                <span style="color: #4f97d7; font-weight: bold;">break</span>;        <span style="color: #2d9574;">}</span>    <span style="color: #bc6ec5;">}</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;<span style="color: #4f97d7;">}</span></pre></div><p>topLevelExec方法是执行本地队列任务及窃取任务的主要方法，窃取任务从指定窃取队列以FIFO的顺序取出;而本地队列FIFO还是LIFO，则由构造器方法中的asyncMode决定（默认为false，也就是LIFO）。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #bc6ec5; font-weight: bold;">ForkJoinPool</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">parallelism</span>,                    <span style="color: #ce537a; font-weight: bold;">ForkJoinWorkerThreadFactory</span> <span style="color: #7590db;">factory</span>,                    <span style="color: #ce537a; font-weight: bold;">UncaughtExceptionHandler</span> <span style="color: #7590db;">handler</span>,                    <span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #7590db;">asyncMode</span><span style="color: #4f97d7;">)</span>mode = parallelism | <span style="color: #4f97d7;">(</span>asyncMode ? FIFO : <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span>;</pre></div><p>考虑到调用该方法时，本地队列中必定是不存在任务的，因此该次调用中直接执行窃取队列首部的ForkJoinTask。之后每执行n次(&gt;= 2^10)本地队列任务，尝试执行一次窃取队列任务。当本地及窃取队列均没有待执行任务时，返回到runWork方法，调整窃取的随机数r后，继续调用scan方法寻找合适的窃取队列。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">topLevelExec</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">ForkJoinTask</span><span style="color: #bc6ec5;">&lt;</span>?<span style="color: #bc6ec5;">&gt;</span> <span style="color: #7590db;">t</span>, <span style="color: #ce537a; font-weight: bold;">WorkQueue</span> <span style="color: #7590db;">q</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">n</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nstolen</span> = <span style="color: #a45bad;">1</span>;    <span style="color: #4f97d7; font-weight: bold;">for</span> <span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">j</span> = <span style="color: #a45bad;">0</span>;;<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>t != <span style="color: #a45bad;">null</span><span style="color: #2d9574;">)</span>            t.doExec<span style="color: #2d9574;">()</span>;        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>j++ &lt;= n<span style="color: #2d9574;">)</span>            t = nextLocalTask<span style="color: #2d9574;">()</span>;        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #2d9574;">{</span>            j = <span style="color: #a45bad;">0</span>;            t = <span style="color: #a45bad;">null</span>;        <span style="color: #2d9574;">}</span>        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>t == <span style="color: #a45bad;">null</span><span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>q != <span style="color: #a45bad;">null</span> &amp;&amp; <span style="color: #b1951d;">(</span>t = q.poll<span style="color: #4f97d7;">()</span><span style="color: #b1951d;">)</span> != <span style="color: #a45bad;">null</span><span style="color: #67b11d;">)</span> <span style="color: #67b11d;">{</span>                ++nstolen;                j = <span style="color: #a45bad;">0</span>;            <span style="color: #67b11d;">}</span>            <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>j != <span style="color: #a45bad;">0</span><span style="color: #67b11d;">)</span>                <span style="color: #4f97d7; font-weight: bold;">break</span>;        <span style="color: #2d9574;">}</span>    <span style="color: #bc6ec5;">}</span>    <span style="color: #ce537a; font-weight: bold;">ForkJoinWorkerThread</span> <span style="color: #7590db;">thread</span> = owner;    nsteals += nstolen;    source = <span style="color: #a45bad;">0</span>;    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>thread != <span style="color: #a45bad;">null</span><span style="color: #bc6ec5;">)</span>        thread.afterTopLevelExec<span style="color: #bc6ec5;">()</span>;<span style="color: #4f97d7;">}</span></pre></div></div></div><div id="outline-container-orgd5a8d90" class="outline-2"><h2 id="orgd5a8d90">join阻塞时的窃取</h2><div class="outline-text-2" id="text-orgd5a8d90"><p>forkjoin任务的join操作主要是通过调用doJoin方法来完成的。在该方法中，可以看到其根据当前线程是否是forkjoin工作线程(ForkJoinWorkerThread)分别采取两种不同的策略。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">doJoin</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span>; <span style="color: #ce537a; font-weight: bold;">Thread</span> <span style="color: #7590db;">t</span>; <span style="color: #ce537a; font-weight: bold;">ForkJoinWorkerThread</span> <span style="color: #7590db;">wt</span>; <span style="color: #a45bad;">ForkJoinPool</span>.<span style="color: #ce537a; font-weight: bold;">WorkQueue</span> <span style="color: #7590db;">w</span>;    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5;">(</span>s = status<span style="color: #bc6ec5;">)</span> &lt; <span style="color: #a45bad;">0</span> ? s :        <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>t = Thread.currentThread<span style="color: #67b11d;">()</span><span style="color: #2d9574;">)</span> <span style="color: #4f97d7; font-weight: bold;">instanceof</span> ForkJoinWorkerThread<span style="color: #bc6ec5;">)</span> ?        <span style="color: #bc6ec5;">(</span>w = <span style="color: #2d9574;">(</span>wt = <span style="color: #67b11d;">(</span><span style="color: #ce537a; font-weight: bold;">ForkJoinWorkerThread</span><span style="color: #67b11d;">)</span>t<span style="color: #2d9574;">)</span>.workQueue<span style="color: #bc6ec5;">)</span>.        tryUnpush<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span><span style="color: #bc6ec5;">)</span> &amp;&amp; <span style="color: #bc6ec5;">(</span>s = doExec<span style="color: #2d9574;">()</span><span style="color: #bc6ec5;">)</span> &lt; <span style="color: #a45bad;">0</span> ? s :        wt.pool.awaitJoin<span style="color: #bc6ec5;">(</span>w, <span style="color: #4f97d7; font-weight: bold;">this</span>, <span style="color: #a45bad;">0L</span><span style="color: #bc6ec5;">)</span> :        externalAwaitDone<span style="color: #bc6ec5;">()</span>;<span style="color: #4f97d7;">}</span></pre></div></div><div id="outline-container-orga3d1f31" class="outline-3"><h3 id="orga3d1f31">非ForkJoinWorkerThread的Join</h3><div class="outline-text-3" id="text-orga3d1f31"><p>对于非ForkJoinWorkerThread的外部线程来说，其不会窃取执行其他任务。只会在阻塞等待任务前，调用tryExternalHelp方法，尝试当前线程直接执行提交任务。是否能直接执行提交任务，取决于是否能够满足下面三个条件。值得注意的是，外部线程执行过程中产生的子任务将提交到common池(ForkJoinPool.common)中。</p><ol class="org-ol"><li>任务提交在common池中</li><li>任务提交时的线程Probe值和当前的指向同一个提交队列</li><li>任务位于队列尾部</li></ol><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">tryExternalHelp</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span>;    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>s = status<span style="color: #2d9574;">)</span> &lt; <span style="color: #a45bad;">0</span> ? s:            <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span> <span style="color: #4f97d7; font-weight: bold;">instanceof</span> CountedCompleter<span style="color: #2d9574;">)</span> ?            ForkJoinPool.common.externalHelpComplete<span style="color: #2d9574;">(</span>                <span style="color: #67b11d;">(</span><span style="color: #ce537a; font-weight: bold;">CountedCompleter</span><span style="color: #b1951d;">&lt;</span>?<span style="color: #b1951d;">&gt;</span><span style="color: #67b11d;">)</span><span style="color: #4f97d7; font-weight: bold;">this</span>, <span style="color: #a45bad;">0</span><span style="color: #2d9574;">)</span> :            ForkJoinPool.common.tryExternalUnpush<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span><span style="color: #2d9574;">)</span> ?            doExec<span style="color: #2d9574;">()</span> : <span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span>;<span style="color: #4f97d7;">}</span><span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #bc6ec5; font-weight: bold;">tryExternalUnpush</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">ForkJoinTask</span><span style="color: #bc6ec5;">&lt;</span>?<span style="color: #bc6ec5;">&gt;</span> <span style="color: #7590db;">task</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">r</span> = ThreadLocalRandom.getProbe<span style="color: #bc6ec5;">()</span>;    <span style="color: #ce537a; font-weight: bold;">WorkQueue</span><span style="color: #bc6ec5;">[]</span> <span style="color: #7590db;">ws</span>; <span style="color: #ce537a; font-weight: bold;">WorkQueue</span> <span style="color: #7590db;">w</span>; <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">n</span>;    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>ws = workQueues<span style="color: #2d9574;">)</span> != <span style="color: #a45bad;">null</span> &amp;&amp;            <span style="color: #2d9574;">(</span>n = ws.length<span style="color: #2d9574;">)</span> &gt; <span style="color: #a45bad;">0</span> &amp;&amp;            <span style="color: #2d9574;">(</span>w = ws<span style="color: #67b11d;">[</span><span style="color: #b1951d;">(</span>n - <span style="color: #a45bad;">1</span><span style="color: #b1951d;">)</span> &amp; r &amp; SQMASK<span style="color: #67b11d;">]</span><span style="color: #2d9574;">)</span> != <span style="color: #a45bad;">null</span> &amp;&amp;            w.tryLockedUnpush<span style="color: #2d9574;">(</span>task<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;<span style="color: #4f97d7;">}</span></pre></div></div></div><div id="outline-container-org96a8307" class="outline-3"><h3 id="org96a8307">ForkJoinWorkerThread的Join</h3><div class="outline-text-3" id="text-org96a8307"><p>对于forkjoin工作线程来说，当等待join的任务位于当前线程的工作队列尾部时，尝试直接执行当前任务。否则调用forkJoinWorkerThread.pool.awaitJoin方法。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">doJoin</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span>; <span style="color: #ce537a; font-weight: bold;">Thread</span> <span style="color: #7590db;">t</span>; <span style="color: #ce537a; font-weight: bold;">ForkJoinWorkerThread</span> <span style="color: #7590db;">wt</span>; <span style="color: #a45bad;">ForkJoinPool</span>.<span style="color: #ce537a; font-weight: bold;">WorkQueue</span> <span style="color: #7590db;">w</span>;    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5;">(</span>s = status<span style="color: #bc6ec5;">)</span> &lt; <span style="color: #a45bad;">0</span> ? s :        <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>t = Thread.currentThread<span style="color: #67b11d;">()</span><span style="color: #2d9574;">)</span> <span style="color: #4f97d7; font-weight: bold;">instanceof</span> ForkJoinWorkerThread<span style="color: #bc6ec5;">)</span> ?        <span style="color: #bc6ec5;">(</span>w = <span style="color: #2d9574;">(</span>wt = <span style="color: #67b11d;">(</span><span style="color: #ce537a; font-weight: bold;">ForkJoinWorkerThread</span><span style="color: #67b11d;">)</span>t<span style="color: #2d9574;">)</span>.workQueue<span style="color: #bc6ec5;">)</span>.        tryUnpush<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span><span style="color: #bc6ec5;">)</span> &amp;&amp; <span style="color: #bc6ec5;">(</span>s = doExec<span style="color: #2d9574;">()</span><span style="color: #bc6ec5;">)</span> &lt; <span style="color: #a45bad;">0</span> ? s :        wt.pool.awaitJoin<span style="color: #bc6ec5;">(</span>w, <span style="color: #4f97d7; font-weight: bold;">this</span>, <span style="color: #a45bad;">0L</span><span style="color: #bc6ec5;">)</span> :        externalAwaitDone<span style="color: #bc6ec5;">()</span>;<span style="color: #4f97d7;">}</span></pre></div><p>在awaitJoin方法中，其首先通过tryRemoveAndExec方法，在w(本地工作队列)中查找并执行等待join的任务。如果依旧是未完成状态，其将进行如下的窃取循环:</p><ol class="org-ol"><li>在子任务工作队列(奇数索引)中窃取队列头部的task执行。</li><li>任务完成则退出。</li><li>当子任务工作队列均为空队列，且tryCompensate方法返回值非0，则阻塞至deadline，否则重新进行窃取循环。</li></ol><p>tryCompensate方法在没有足够的工作线程时，会创建或激活一个空闲线程来补偿join线程阻塞导致的并行度不足。该方法返回0表示需要重试，其仅在工作队列状态不一致或cas更新状态失败时出现。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">awaitJoin</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">WorkQueue</span> <span style="color: #7590db;">w</span>, <span style="color: #ce537a; font-weight: bold;">ForkJoinTask</span><span style="color: #bc6ec5;">&lt;</span>?<span style="color: #bc6ec5;">&gt;</span> <span style="color: #7590db;">task</span>, <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">deadline</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span> = <span style="color: #a45bad;">0</span>;    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">seed</span> = ThreadLocalRandom.nextSecondarySeed<span style="color: #bc6ec5;">()</span>;    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>w != <span style="color: #a45bad;">null</span> &amp;&amp; task != <span style="color: #a45bad;">null</span> &amp;&amp;        <span style="color: #2d9574;">(</span><span style="color: #a45bad;">!</span><span style="color: #67b11d;">(</span>task <span style="color: #4f97d7; font-weight: bold;">instanceof</span> CountedCompleter<span style="color: #67b11d;">)</span> ||         <span style="color: #67b11d;">(</span>s = w.helpCC<span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">CountedCompleter</span><span style="color: #bc6ec5;">&lt;</span>?<span style="color: #bc6ec5;">&gt;</span><span style="color: #4f97d7;">)</span>task, <span style="color: #a45bad;">0</span>, <span style="color: #a45bad;">false</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span> &gt;= <span style="color: #a45bad;">0</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>        w.tryRemoveAndExec<span style="color: #2d9574;">(</span>task<span style="color: #2d9574;">)</span>;        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">src</span> = w.source, <span style="color: #7590db;">id</span> = w.id;        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">r</span> = <span style="color: #2d9574;">(</span>seed &gt;&gt;&gt; <span style="color: #a45bad;">16</span><span style="color: #2d9574;">)</span> | <span style="color: #a45bad;">1</span>, <span style="color: #7590db;">step</span> = <span style="color: #2d9574;">(</span>seed &amp; ~<span style="color: #a45bad;">1</span><span style="color: #2d9574;">)</span> | <span style="color: #a45bad;">2</span>;        s = task.status;        <span style="color: #4f97d7; font-weight: bold;">while</span> <span style="color: #2d9574;">(</span>s &gt;= <span style="color: #a45bad;">0</span><span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            <span style="color: #ce537a; font-weight: bold;">WorkQueue</span><span style="color: #67b11d;">[]</span> <span style="color: #7590db;">ws</span>;            <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">n</span> = <span style="color: #67b11d;">(</span>ws = workQueues<span style="color: #67b11d;">)</span> == <span style="color: #a45bad;">null</span> ? <span style="color: #a45bad;">0</span> : ws.length, <span style="color: #7590db;">m</span> = n - <span style="color: #a45bad;">1</span>;            <span style="color: #4f97d7; font-weight: bold;">while</span> <span style="color: #67b11d;">(</span>n &gt; <span style="color: #a45bad;">0</span><span style="color: #67b11d;">)</span> <span style="color: #67b11d;">{</span>                <span style="color: #ce537a; font-weight: bold;">WorkQueue</span> <span style="color: #7590db;">q</span>; <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">b</span>;                <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>q = ws<span style="color: #bc6ec5;">[</span>r &amp; m<span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span> != <span style="color: #a45bad;">null</span> &amp;&amp; q.source == id &amp;&amp;                    q.top != <span style="color: #4f97d7;">(</span>b = q.base<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span> <span style="color: #b1951d;">{</span>                     <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">&#25191;&#34892;&#38431;&#21015;&#22836;&#37096;&#20219;&#21153; */</span>                    <span style="color: #4f97d7; font-weight: bold;">break</span>;                <span style="color: #b1951d;">}</span>                <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #b1951d;">{</span>                    r += step;                    --n;                <span style="color: #b1951d;">}</span>            <span style="color: #67b11d;">}</span>            <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span><span style="color: #b1951d;">(</span>s = task.status<span style="color: #b1951d;">)</span> &lt; <span style="color: #a45bad;">0</span><span style="color: #67b11d;">)</span>                <span style="color: #4f97d7; font-weight: bold;">break</span>;            <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>n == <span style="color: #a45bad;">0</span><span style="color: #67b11d;">)</span> <span style="color: #67b11d;">{</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">empty scan</span>                <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">ms</span>, <span style="color: #7590db;">ns</span>; <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">block</span>;                <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>ns = deadline - System.nanoTime<span style="color: #bc6ec5;">()</span><span style="color: #4f97d7;">)</span> &lt;= <span style="color: #a45bad;">0L</span><span style="color: #b1951d;">)</span>                    <span style="color: #4f97d7; font-weight: bold;">break</span>;                         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">timeout</span>                <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>ms = <span style="color: #a45bad;">TimeUnit</span>.NANOSECONDS.toMillis<span style="color: #bc6ec5;">(</span>ns<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> &lt;= <span style="color: #a45bad;">0L</span><span style="color: #b1951d;">)</span>                    ms = <span style="color: #a45bad;">1L</span>;                       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">avoid 0 for timed wait</span>                <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>block = tryCompensate<span style="color: #bc6ec5;">(</span>w<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> != <span style="color: #a45bad;">0</span><span style="color: #b1951d;">)</span> <span style="color: #b1951d;">{</span>                    task.internalWait<span style="color: #4f97d7;">(</span>ms<span style="color: #4f97d7;">)</span>;                    CTL.getAndAdd<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>, <span style="color: #bc6ec5;">(</span>block &gt; <span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span> ? RC_UNIT : <span style="color: #a45bad;">0L</span><span style="color: #4f97d7;">)</span>;                <span style="color: #b1951d;">}</span>                s = task.status;            <span style="color: #67b11d;">}</span>        <span style="color: #2d9574;">}</span>    <span style="color: #bc6ec5;">}</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> s;<span style="color: #4f97d7;">}</span></pre></div></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;
从jdk1.7开始，jdk提供了ForkJoin相关工具类。
与其他ExecutorService实现相比，其能够充分地利用多核优势来提高执行性能:
&lt;/p&gt;
&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;通过采用工作窃取算法，使得未被分配任务的工作线程也能从忙碌线程那
      
    
    </summary>
    
      <category term="java" scheme="http://summerisgreen.com/categories/java/"/>
    
    
      <category term="java" scheme="http://summerisgreen.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ScheduledThreadPool中的Leader-Follow模式</title>
    <link href="http://summerisgreen.com/blog/2020-02-02-2020-02-02-schedulethreadpool%E4%B8%AD%E7%9A%84leader-follow%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://summerisgreen.com/blog/2020-02-02-2020-02-02-schedulethreadpool中的leader-follow模式.html</id>
    <published>2020-02-01T16:00:00.000Z</published>
    <updated>2020-02-03T06:13:16.623Z</updated>
    
    <content type="html"><![CDATA[<p>ScheduledThreadPoolExecutor 是java中一个非常常用的定时调度的工具，其提供了两种定时调度常用模式:1.固定调度周期的任务执行。2.固定延迟间隔的任务执行，延迟间隔表示的是前一次执行完成到后一次执行开始的时间差。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #a45bad;">1</span>.scheduleAtFixedRate<span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Runnable</span> <span style="color: #7590db;">command</span>,<span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">initialDelay</span>,<span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">period</span>,<span style="color: #ce537a; font-weight: bold;">TimeUnit</span> <span style="color: #7590db;">unit</span><span style="color: #4f97d7;">)</span><span style="color: #a45bad;">2</span>.scheduleWithFixedDelay<span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Runnable</span> <span style="color: #7590db;">command</span>,<span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">initialDelay</span>,<span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">delay</span>,<span style="color: #ce537a; font-weight: bold;">TimeUnit</span> <span style="color: #7590db;">unit</span><span style="color: #4f97d7;">)</span> </pre></div><p>ScheduledThreadPoolExecutor 是基于ThreadPoolExecutor实现的，其继承了类ThreadPoolExecutor。从构造器可以看出，为满足定时调度的需求，其基于ThreadPoolExecutor定制了延迟工作队列DelayedWorkQueue。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #bc6ec5; font-weight: bold;">ScheduledThreadPoolExecutor</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">corePoolSize</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>     <span style="color: #4f97d7; font-weight: bold;">super</span><span style="color: #bc6ec5;">(</span>corePoolSize, <span style="color: #a45bad;">Integer</span>.MAX_VALUE,           DEFAULT_KEEPALIVE_MILLIS <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">10L*/</span>, MILLISECONDS,           <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">DelayedWorkQueue</span><span style="color: #2d9574;">()</span><span style="color: #bc6ec5;">)</span>;<span style="color: #4f97d7;">}</span></pre></div><p>DelayedWorkQueue是一个基于最小堆的队列，其在元素进出队列等BlockingQueue接口方法中使用可重入锁，以保证线程安全。为了在O(1)的时间取消特定任务的调度，ScheduleFutrueTask对象中还额外增加了heapIndex字段，以记录其在最小堆中的位置。</p><div id="outline-container-orgd5da137" class="outline-2"><h2 id="orgd5da137">Leader-Follower模式</h2><div class="outline-text-2" id="text-orgd5da137"><p>定时调度线程池与一般线程池的一个重要不同:提交的任务是延迟而非立即执行的，因此worker线程调用队列的take以取出执行任务必定是要阻塞的。考虑到等待延迟执行任务的线程无需都使用timed waiting等待队首任务，一个task的执行线程只有一个，全部唤醒只会造成大量无效的线程唤醒和阻塞操作。</p><p>ScheduledThreadPool采用了Leader-Follower模式，等待第一个线程的任务也称为leader，其调用available.awaitNanos待当前队列头部任务到达调度时间时唤醒。其余线程作为follower只需调用await方法无限阻塞等待，直至被leader唤醒，并重新完成抢锁-&gt;尝试执行队列首元素-&gt;抢leader-&gt;等待的循环。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">RunnableScheduledFuture</span><span style="color: #4f97d7;">&lt;</span>?<span style="color: #4f97d7;">&gt;</span> <span style="color: #bc6ec5; font-weight: bold;">take</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7; font-weight: bold;">throws</span> <span style="color: #ce537a; font-weight: bold;">InterruptedException</span> <span style="color: #4f97d7;">{</span>    <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">ReentrantLock</span> <span style="color: #7590db;">lock</span> = <span style="color: #4f97d7; font-weight: bold;">this</span>.lock;    lock.lockInterruptibly<span style="color: #bc6ec5;">()</span>;    <span style="color: #4f97d7; font-weight: bold;">try</span> <span style="color: #bc6ec5;">{</span>        <span style="color: #4f97d7; font-weight: bold;">for</span> <span style="color: #2d9574;">(</span>;;<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            <span style="color: #ce537a; font-weight: bold;">RunnableScheduledFuture</span><span style="color: #67b11d;">&lt;</span>?<span style="color: #67b11d;">&gt;</span> <span style="color: #7590db;">first</span> = queue<span style="color: #67b11d;">[</span><span style="color: #a45bad;">0</span><span style="color: #67b11d;">]</span>;            <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>first == <span style="color: #a45bad;">null</span><span style="color: #67b11d;">)</span>                available.await<span style="color: #67b11d;">()</span>;            <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #67b11d;">{</span>                <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">delay</span> = first.getDelay<span style="color: #b1951d;">(</span>NANOSECONDS<span style="color: #b1951d;">)</span>;                <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span>delay &lt;= <span style="color: #a45bad;">0L</span><span style="color: #b1951d;">)</span>                    <span style="color: #4f97d7; font-weight: bold;">return</span> finishPoll<span style="color: #b1951d;">(</span>first<span style="color: #b1951d;">)</span>;                first = <span style="color: #a45bad;">null</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">don't retain ref while waiting</span>                <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span>leader != <span style="color: #a45bad;">null</span><span style="color: #b1951d;">)</span>                    available.await<span style="color: #b1951d;">()</span>;                <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #b1951d;">{</span>                    <span style="color: #ce537a; font-weight: bold;">Thread</span> <span style="color: #7590db;">thisThread</span> = Thread.currentThread<span style="color: #4f97d7;">()</span>;                    leader = thisThread;                    <span style="color: #4f97d7; font-weight: bold;">try</span> <span style="color: #4f97d7;">{</span>                        available.awaitNanos<span style="color: #bc6ec5;">(</span>delay<span style="color: #bc6ec5;">)</span>;                    <span style="color: #4f97d7;">}</span> <span style="color: #4f97d7; font-weight: bold;">finally</span> <span style="color: #4f97d7;">{</span>                        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>leader == thisThread<span style="color: #bc6ec5;">)</span>                            leader = <span style="color: #a45bad;">null</span>;                    <span style="color: #4f97d7;">}</span>                <span style="color: #b1951d;">}</span>            <span style="color: #67b11d;">}</span>        <span style="color: #2d9574;">}</span>    <span style="color: #bc6ec5;">}</span> <span style="color: #4f97d7; font-weight: bold;">finally</span> <span style="color: #bc6ec5;">{</span>        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>leader == <span style="color: #a45bad;">null</span> &amp;&amp; queue<span style="color: #67b11d;">[</span><span style="color: #a45bad;">0</span><span style="color: #67b11d;">]</span> != <span style="color: #a45bad;">null</span><span style="color: #2d9574;">)</span>            available.signal<span style="color: #2d9574;">()</span>;        lock.unlock<span style="color: #2d9574;">()</span>;    <span style="color: #bc6ec5;">}</span><span style="color: #4f97d7;">}</span></pre></div><p>若新增元素位于堆顶，此时需安排等待该元素定期调度或立即执行的leader线程。为此offer方法在新增元素应率先调度时，清空leader，并signal唤醒某个等待线程，继续take方法中的循环:抢锁-&gt;尝试执行队首元素-&gt;抢leader-&gt;等待。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #bc6ec5; font-weight: bold;">offer</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Runnable</span> <span style="color: #7590db;">x</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>    <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">ReentrantLock</span> <span style="color: #7590db;">lock</span> = <span style="color: #4f97d7; font-weight: bold;">this</span>.lock;    lock.lock<span style="color: #bc6ec5;">()</span>;    <span style="color: #4f97d7; font-weight: bold;">try</span> <span style="color: #bc6ec5;">{</span>        <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">        insert into queue</span><span style="color: #2aa1ae; background-color: #292e34;">        */</span>        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>queue<span style="color: #67b11d;">[</span><span style="color: #a45bad;">0</span><span style="color: #67b11d;">]</span> == e<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            leader = <span style="color: #a45bad;">null</span>;            available.signal<span style="color: #67b11d;">()</span>;        <span style="color: #2d9574;">}</span>    <span style="color: #bc6ec5;">}</span> <span style="color: #4f97d7; font-weight: bold;">finally</span> <span style="color: #bc6ec5;">{</span>        lock.unlock<span style="color: #2d9574;">()</span>;    <span style="color: #bc6ec5;">}</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;<span style="color: #4f97d7;">}</span></pre></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;
ScheduledThreadPoolExecutor 是java中一个非常常用的定时调度的工具，其提供了两种定时调度常用模式:
1.固定调度周期的任务执行。
2.固定延迟间隔的任务执行，延迟间隔表示的是前一次执行完成到后一次执行开始的时间差。
&lt;/p&gt;
&lt;div cla
      
    
    </summary>
    
      <category term="java" scheme="http://summerisgreen.com/categories/java/"/>
    
    
      <category term="java" scheme="http://summerisgreen.com/tags/java/"/>
    
      <category term="源码" scheme="http://summerisgreen.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ES查询性能优化-优先选择keyword类型</title>
    <link href="http://summerisgreen.com/blog/2019-12-01-2019-12-01-es%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9keyword%E7%B1%BB%E5%9E%8B.html"/>
    <id>http://summerisgreen.com/blog/2019-12-01-2019-12-01-es查询性能优化-优先选择keyword类型.html</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-05T16:51:25.028Z</updated>
    
    <content type="html"><![CDATA[<p>线上一个es查询越來越慢，而且cpu使用率也越來越高，逼近了比较危险的60%。在公司的es专家帮忙profile了慢查询后，发现大量时间开销花在一个只有0和1两种取值的int型字段term查询上(build_scorer耗时非常高)，让我们把不需要数学计算及范围查询的数值类型都改为keyword。</p><p>完成字段类型修改后，我们还针对过滤后集合较小的场景使用了map的聚合数据结构，果然性能从之前的300ms提升到20ms,并且cpu使用率也降到了5%以下，可以说效果非常显著。这也带来了一个疑惑，es的索引字段类型keyword和number为何性能会相差如此之多。</p><div id="outline-container-org8474fd1" class="outline-2"><h2 id="org8474fd1">优先使用keyword而不是number</h2><div class="outline-text-2" id="text-org8474fd1"><p>由于从es 5.x开始，其使用了block k-d tree作为数值型字段的数据结构, 而不再是倒排索引,number和keyword查询适用范围也发生了很多差别，关于两者的具体，<a href="https://elasticsearch.cn/article/446" target="_blank" rel="noopener">wood大叔的一篇文章</a>讲的非常透彻。 </p><p>对于不关心细节的使用者来说，只要把握如下两个原则即可:</p><ul class="org-ul"><li>对于不需要范围查询和数值比较的字段，尽可能用keyword</li><li>如果profile发现，大量时间开销将花费在build_scorer上，可以考虑下是否有number型字段需要替换成keyword</li></ul><p>keyword和number底层数据结构的区别以及适用的查询方式如下表所示:</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="org-left"></colgroup><colgroup><col class="org-left"></colgroup><colgroup><col class="org-left"></colgroup><colgroup><col class="org-left"></colgroup><thead><tr><th scope="col" class="org-left">字段类型</th><th scope="col" class="org-left">数据结构</th><th scope="col" class="org-left">已有起始集合的term查询</th><th scope="col" class="org-left">range查询</th></tr></thead><tbody><tr><td class="org-left">keyword</td><td class="org-left">倒排索引</td><td class="org-left">利用跳表快速定位docid</td><td class="org-left">区间内所有枚举值的term查询结果的合并(OR)</td></tr></tbody><tbody><tr><td class="org-left">number</td><td class="org-left">Block k-d tree</td><td class="org-left">PointRangeQuery:满足条件的docid构建bitset</td><td class="org-left">获取叶节点上的所有docid，扫描并和range范围比较</td></tr></tbody></table><p>通过观察上述表格，解释了为何一个只有0和1两种取值的int型字段term查询非常慢:该term查询筛选出的集合非常之大，以至于光是构造bitset都非常耗时。而将该类型转化为keyword后，在代价低的查询构造完迭代器后，其可以利用跳表快速判断迭代器中的docid是否满足要求。</p><p>由于存在当rangeQuery的结果集巨大，而你却要为了验证少数几个docid是否存在，而不得不遍历整个结果集的问题，es 5.4引入了<a href="https://www.elastic.co/cn/blog/better-query-planning-for-range-queries-in-elasticsearch" target="_blank" rel="noopener">indexOrDocValuesQuery</a>。其对于遍历整个结果集的顺序访问场景，使用原有的PointRangeQuery。而对于仅仅验证少部分结果是否存在的随即访问场景,其将采用新引入的SortedSetDocValuesRangeQuery:从代价更低的query构造出的迭代器中，依次取出doc id并去磁盘(随机访问)匹配value。</p></div></div><div id="outline-container-orga69abc6" class="outline-2"><h2 id="orga69abc6">为何聚合依旧很慢</h2><div class="outline-text-2" id="text-orga69abc6"><p>当将能改成keyword的索引字段都改成keyword后，发现个很神奇的现象，一个query第一次查询时甚至比优化前慢多了达到秒级别，但多尝试几次后又很快，达到20多ms。经过对查询条件进行多次调整尝试，发现上述问题是对区分度较高的keyword字段(原先为数值型)进行聚合而导致的。</p><p><a href="https://www.elastic.co/cn/blog/improving-the-performance-of-high-cardinality-terms-aggregations-in-elasticsearch" target="_blank" rel="noopener">查询资料</a>后了解到，ES默认聚合采用global ordinals的数据结构对聚合字段进行bucket分组，其适合包含的原始文档非常多的情况。但当新数据刷入后的查询需要重建global ordinals数据结构，此时将会产生慢查询，并且重建时间随着区分度的增加而增加。可通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/eager-global-ordinals.html" target="_blank" rel="noopener">enable eager global ordinals</a>,让其在segments更新时自动更新全局global ordinals，从而保证查询稳定性。</p><p>在我们的场景中，由于terms过滤后只剩少量文档需要聚合，可以采用直接在内存map中进行聚合的方案。可以设置execution_hint:map达到此效果。不过在6.7版本前，由于存在bug，需要将查询语句改写成script才能走map的聚合计划。具体可参考如下示例。</p><pre class="example">"aggregations" : {    "top-ibans" : {         "terms" : {             "script": {                 "source" : "doc['IBAN_keyword'].value",                 "lang" : "painless"             }         }     }}</pre></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;
线上一个es查询越來越慢，而且cpu使用率也越來越高，逼近了比较危险的60%。
在公司的es专家帮忙profile了慢查询后，发现大量时间开销花在一个只有0和1两种取值的int型字段term查询上(build_scorer耗时非常高)，让我们把不需要数学计算及范围查询的数
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://summerisgreen.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://summerisgreen.com/tags/elasticsearch/"/>
    
      <category term="性能优化" scheme="http://summerisgreen.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>FutureTask源码简析</title>
    <link href="http://summerisgreen.com/blog/2019-03-03-2019-03-03-futuretask%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA.html"/>
    <id>http://summerisgreen.com/blog/2019-03-03-2019-03-03-futuretask中的状态机.html</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-12-01T15:10:27.849Z</updated>
    
    <content type="html"><![CDATA[<p>由于FutureTask可能在多个线程中触发执行或者取消逻辑,如果没有线程安全保证，可能会出现执行已取消操作，异步操作被多次执行等违反Futuretask语义的情形。为了保证FutureTask的线程安全，jdk结合使用了状态机和cas操作。</p><div id="outline-container-org51394a9" class="outline-2"><h2 id="org51394a9">FutureTask中的状态机</h2><div class="outline-text-2" id="text-org51394a9"></div><div id="outline-container-org688eae3" class="outline-3"><h3 id="org688eae3">状态机设计</h3><div class="outline-text-3" id="text-org688eae3"><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">NEW</span>          = <span style="color: #a45bad;">0</span>;<span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">COMPLETING</span>   = <span style="color: #a45bad;">1</span>;<span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">NORMAL</span>       = <span style="color: #a45bad;">2</span>;<span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">EXCEPTIONAL</span>  = <span style="color: #a45bad;">3</span>;<span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">CANCELLED</span>    = <span style="color: #a45bad;">4</span>;<span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">INTERRUPTING</span> = <span style="color: #a45bad;">5</span>;<span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">INTERRUPTED</span>  = <span style="color: #a45bad;">6</span>;</pre></div></div></div><div id="outline-container-orgf2f2d74" class="outline-3"><h3 id="orgf2f2d74">状态的变化</h3><div class="outline-text-3" id="text-orgf2f2d74"><p>在FutureTask中，一共存在上面所述7种状态，其中New为实例的初始化状态，Completing和Interrupting为中间状态，其余四个为最终状态。</p><ul class="org-ul"><li>New-&gt;Completing-&gt;Normal</li><li>New-&gt;Completing-&gt;Exceptional</li><li>New-&gt;Cancelled</li><li>New-&gt;Interrupting-&gt;Interrupted</li></ul></div></div></div><div id="outline-container-org07fb37f" class="outline-2"><h2 id="org07fb37f">并发问题的解决</h2><div class="outline-text-2" id="text-org07fb37f"></div><div id="outline-container-org8302213" class="outline-3"><h3 id="org8302213">争夺状态改变权</h3><div class="outline-text-3" id="text-org8302213"><p>对于初始化状态New，正如之前看到的，其可能有四种状态演化的方式，而这四种状态演化方式主要是通过调用cancel,set和setException三个方法来获得的。</p><ul class="org-ul"><li>cancel操作: New-&gt;Interrupting-&gt;Interrupted</li><li>cancel操作: New-&gt;Cancel</li><li>set操作: New-&gt;Completing-&gt;Normal</li><li>setException操作: New-&gt;Completing-&gt;Exceptional</li></ul><p>由于对FutureTask实例存在cancel,set,setException操作的并发调用，为了避免状态演化的混乱，这三种方法均采用cas操作来争夺唯一的状态改变权。表现在源码中，这几个方法都通过调用STATE.compareAndSet来试图获取状态控制权。当获取到状态控制权之后，表面该线程是唯一修改状态变量的线程，因此可以直接继续操作状态值(比如set方法中:STATE.setRelease(this, NORMAL))，而无需再使用对性能有消耗的cas操作了。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">set</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">V</span> <span style="color: #7590db;">v</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>STATE.compareAndSet<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>, NEW, COMPLETING<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>        outcome = v;        STATE.setRelease<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>, NORMAL<span style="color: #2d9574;">)</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">final state</span>        finishCompletion<span style="color: #2d9574;">()</span>;    <span style="color: #bc6ec5;">}</span><span style="color: #4f97d7;">}</span><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #bc6ec5; font-weight: bold;">cancel</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #7590db;">mayInterruptIfRunning</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span><span style="color: #2d9574;">(</span>state == NEW &amp;&amp; STATE.compareAndSet          <span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;    <span style="color: #4f97d7; font-weight: bold;">try</span> <span style="color: #bc6ec5;">{</span>    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">in case call to interrupt throws exception</span>        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>mayInterruptIfRunning<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            <span style="color: #4f97d7; font-weight: bold;">try</span> <span style="color: #67b11d;">{</span>                <span style="color: #ce537a; font-weight: bold;">Thread</span> <span style="color: #7590db;">t</span> = runner;                <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span>t != <span style="color: #a45bad;">null</span><span style="color: #b1951d;">)</span>                    t.interrupt<span style="color: #b1951d;">()</span>;            <span style="color: #67b11d;">}</span> <span style="color: #4f97d7; font-weight: bold;">finally</span> <span style="color: #67b11d;">{</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">final state</span>                STATE.setRelease<span style="color: #b1951d;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>, INTERRUPTED<span style="color: #b1951d;">)</span>;            <span style="color: #67b11d;">}</span>        <span style="color: #2d9574;">}</span>    <span style="color: #bc6ec5;">}</span> <span style="color: #4f97d7; font-weight: bold;">finally</span> <span style="color: #bc6ec5;">{</span>        finishCompletion<span style="color: #2d9574;">()</span>;    <span style="color: #bc6ec5;">}</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;<span style="color: #4f97d7;">}</span></pre></div></div></div><div id="outline-container-org70ca8b1" class="outline-3"><h3 id="org70ca8b1">状态码判断</h3><div class="outline-text-3" id="text-org70ca8b1"><p>FutureTask中状态机设计的比较巧妙的一点就是:可以基于状态码的值来快速决定下一步的行动。比如在get方法中，通过比较当前状态和COMPLETING值，来决定是继续等待完成还是调用report方法返回结果。对后者，通过将状态值与NORMAL以及CANCEL值比较，得出最终结果或异常类型。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">V</span> <span style="color: #bc6ec5; font-weight: bold;">get</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7; font-weight: bold;">throws</span> <span style="color: #ce537a; font-weight: bold;">InterruptedException</span>, <span style="color: #ce537a; font-weight: bold;">ExecutionException</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span> = state;    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>s &lt;= COMPLETING<span style="color: #bc6ec5;">)</span>        s = awaitDone<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">false</span>, <span style="color: #a45bad;">0L</span><span style="color: #bc6ec5;">)</span>;    <span style="color: #4f97d7; font-weight: bold;">return</span> report<span style="color: #bc6ec5;">(</span>s<span style="color: #bc6ec5;">)</span>;<span style="color: #4f97d7;">}</span><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">V</span> <span style="color: #bc6ec5; font-weight: bold;">report</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">throws</span> <span style="color: #ce537a; font-weight: bold;">ExecutionException</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">Object</span> <span style="color: #7590db;">x</span> = outcome;    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>s == NORMAL<span style="color: #bc6ec5;">)</span>        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">V</span><span style="color: #bc6ec5;">)</span>x;    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>s &gt;= CANCELLED<span style="color: #bc6ec5;">)</span>        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CancellationException</span><span style="color: #bc6ec5;">()</span>;    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">ExecutionException</span><span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">Throwable</span><span style="color: #2d9574;">)</span>x<span style="color: #bc6ec5;">)</span>;<span style="color: #4f97d7;">}</span></pre></div></div></div><div id="outline-container-org4f52837" class="outline-3"><h3 id="org4f52837">任务执行</h3><div class="outline-text-3" id="text-org4f52837"><p>FutureTask中最重要的方法莫过于run方法了，毕竟FutureTask的核心就是异步执行了。在很多情况下提交的Futuretask任务为耗时任务，在该任务执行前或执行过程中极有可能由于各种原因被取消。因此在run方法的finally中需要进行状态机判断,如果该任务已被取消,需要让出当前线程，等完成取消任务后再继续执行。</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">run</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>state != NEW ||        <span style="color: #a45bad;">!</span>RUNNER.compareAndSet<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>, <span style="color: #a45bad;">null</span>, Thread.currentThread<span style="color: #67b11d;">()</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>        <span style="color: #4f97d7; font-weight: bold;">return</span>;    <span style="color: #4f97d7; font-weight: bold;">try</span> <span style="color: #bc6ec5;">{</span>        <span style="color: #ce537a; font-weight: bold;">Callable</span><span style="color: #2d9574;">&lt;</span><span style="color: #ce537a; font-weight: bold;">V</span><span style="color: #2d9574;">&gt;</span> <span style="color: #7590db;">c</span> = callable;        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>c != <span style="color: #a45bad;">null</span> &amp;&amp; state == NEW<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            <span style="color: #ce537a; font-weight: bold;">V</span> <span style="color: #7590db;">result</span>;            <span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #7590db;">ran</span>;            <span style="color: #4f97d7; font-weight: bold;">try</span> <span style="color: #67b11d;">{</span>                result = c.call<span style="color: #b1951d;">()</span>;                ran = <span style="color: #a45bad;">true</span>;            <span style="color: #67b11d;">}</span> <span style="color: #4f97d7; font-weight: bold;">catch</span> <span style="color: #67b11d;">(</span><span style="color: #ce537a; font-weight: bold;">Throwable</span> <span style="color: #7590db;">ex</span><span style="color: #67b11d;">)</span> <span style="color: #67b11d;">{</span>                result = <span style="color: #a45bad;">null</span>;                ran = <span style="color: #a45bad;">false</span>;                setException<span style="color: #b1951d;">(</span>ex<span style="color: #b1951d;">)</span>;            <span style="color: #67b11d;">}</span>            <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>ran<span style="color: #67b11d;">)</span>                set<span style="color: #67b11d;">(</span>result<span style="color: #67b11d;">)</span>;        <span style="color: #2d9574;">}</span>    <span style="color: #bc6ec5;">}</span> <span style="color: #4f97d7; font-weight: bold;">finally</span> <span style="color: #bc6ec5;">{</span>        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">runner must be non-null until state is settled to</span>        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">prevent concurrent calls to run()</span>        runner = <span style="color: #a45bad;">null</span>;        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">state must be re-read after nulling runner to prevent</span>        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">leaked interrupts</span>        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span> = state;        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>s &gt;= INTERRUPTING<span style="color: #2d9574;">)</span>            handlePossibleCancellationInterrupt<span style="color: #2d9574;">(</span>s<span style="color: #2d9574;">)</span>;    <span style="color: #bc6ec5;">}</span><span style="color: #4f97d7;">}</span><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">handlePossibleCancellationInterrupt</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>s == INTERRUPTING<span style="color: #bc6ec5;">)</span>        <span style="color: #4f97d7; font-weight: bold;">while</span> <span style="color: #bc6ec5;">(</span>state == INTERRUPTING<span style="color: #bc6ec5;">)</span>            Thread.yield<span style="color: #bc6ec5;">()</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wait out pending interrupt</span><span style="color: #4f97d7;">}</span></pre></div><p>值得注意的是，在任务结束后，futuretask类只保留了最终的状态及结果(正确值或异常)，而执行线程信息以及callable回调函数等对象都因不再有用而置null,以便及时被gc回收。</p></div></div><div id="outline-container-org06ae1bb" class="outline-3"><h3 id="org06ae1bb">结果等待</h3><div class="outline-text-3" id="text-org06ae1bb"><p>当用户代码向线程池提交任务后，一个最常见的后续操作就是阻塞(或带超时的阻塞)等待任务结果</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">V</span> <span style="color: #bc6ec5; font-weight: bold;">get</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7; font-weight: bold;">throws</span> <span style="color: #ce537a; font-weight: bold;">InterruptedException</span>, <span style="color: #ce537a; font-weight: bold;">ExecutionException</span> <span style="color: #4f97d7;">{</span>    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span> = state;    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>s &lt;= COMPLETING<span style="color: #bc6ec5;">)</span>        s = awaitDone<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">false</span>, <span style="color: #a45bad;">0L</span><span style="color: #bc6ec5;">)</span>;    <span style="color: #4f97d7; font-weight: bold;">return</span> report<span style="color: #bc6ec5;">(</span>s<span style="color: #bc6ec5;">)</span>;<span style="color: #4f97d7;">}</span><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">V</span> <span style="color: #bc6ec5; font-weight: bold;">get</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">timeout</span>, <span style="color: #ce537a; font-weight: bold;">TimeUnit</span> <span style="color: #7590db;">unit</span><span style="color: #4f97d7;">)</span>    <span style="color: #4f97d7; font-weight: bold;">throws</span> <span style="color: #ce537a; font-weight: bold;">InterruptedException</span>, <span style="color: #ce537a; font-weight: bold;">ExecutionException</span>, <span style="color: #ce537a; font-weight: bold;">TimeoutException</span> <span style="color: #4f97d7;">{</span>    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>unit == <span style="color: #a45bad;">null</span><span style="color: #bc6ec5;">)</span>        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">NullPointerException</span><span style="color: #bc6ec5;">()</span>;    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span> = state;    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>s &lt;= COMPLETING &amp;&amp;        <span style="color: #2d9574;">(</span>s = awaitDone<span style="color: #67b11d;">(</span><span style="color: #a45bad;">true</span>, unit.toNanos<span style="color: #b1951d;">(</span>timeout<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span> &lt;= COMPLETING<span style="color: #bc6ec5;">)</span>        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">TimeoutException</span><span style="color: #bc6ec5;">()</span>;    <span style="color: #4f97d7; font-weight: bold;">return</span> report<span style="color: #bc6ec5;">(</span>s<span style="color: #bc6ec5;">)</span>;<span style="color: #4f97d7;">}</span></pre></div><p>如果此时任务还未完成，其将调用awaitDone方法，利用cas加入队列后，使用park/parkNanos方法阻塞线程，直至被唤醒。其将在下面三种情况下被唤醒:1.线程被中断2.超时阻塞已超时3.完成任务结果及状态记录(正确值或异常结果更新)</p><div class="org-src-container"><pre class="src src-java"><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">awaitDone</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #7590db;">timed</span>, <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">nanos</span><span style="color: #4f97d7;">)</span>    <span style="color: #4f97d7; font-weight: bold;">throws</span> <span style="color: #ce537a; font-weight: bold;">InterruptedException</span> <span style="color: #4f97d7;">{</span>    <span style="color: #4f97d7; font-weight: bold;">final</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">deadline</span> = timed ? System.nanoTime<span style="color: #bc6ec5;">()</span> + nanos : <span style="color: #a45bad;">0L</span>;    <span style="color: #ce537a; font-weight: bold;">WaitNode</span> <span style="color: #7590db;">q</span> = <span style="color: #a45bad;">null</span>;    <span style="color: #ce537a; font-weight: bold;">boolean</span> <span style="color: #7590db;">queued</span> = <span style="color: #a45bad;">false</span>;    <span style="color: #4f97d7; font-weight: bold;">for</span> <span style="color: #bc6ec5;">(</span>;;<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>Thread.interrupted<span style="color: #67b11d;">()</span><span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            removeWaiter<span style="color: #67b11d;">(</span>q<span style="color: #67b11d;">)</span>;            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">InterruptedException</span><span style="color: #67b11d;">()</span>;        <span style="color: #2d9574;">}</span>        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">s</span> = state;        <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>s &gt; COMPLETING<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>q != <span style="color: #a45bad;">null</span><span style="color: #67b11d;">)</span>                q.thread = <span style="color: #a45bad;">null</span>;            <span style="color: #4f97d7; font-weight: bold;">return</span> s;        <span style="color: #2d9574;">}</span>        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>s == COMPLETING<span style="color: #2d9574;">)</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cannot time out yet</span>            Thread.yield<span style="color: #2d9574;">()</span>;        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>q == <span style="color: #a45bad;">null</span><span style="color: #2d9574;">)</span>            q = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">WaitNode</span><span style="color: #2d9574;">()</span>;        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span><span style="color: #a45bad;">!</span>queued<span style="color: #2d9574;">)</span>            queued = UNSAFE.compareAndSwapObject<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>, waitersOffset,                                                 q.next = waiters, q<span style="color: #2d9574;">)</span>;        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>timed<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>            nanos = deadline - System.nanoTime<span style="color: #67b11d;">()</span>;            <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>nanos &lt;= <span style="color: #a45bad;">0L</span><span style="color: #67b11d;">)</span> <span style="color: #67b11d;">{</span>                removeWaiter<span style="color: #b1951d;">(</span>q<span style="color: #b1951d;">)</span>;                <span style="color: #4f97d7; font-weight: bold;">return</span> state;            <span style="color: #67b11d;">}</span>            LockSupport.parkNanos<span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>, nanos<span style="color: #67b11d;">)</span>;        <span style="color: #2d9574;">}</span>        <span style="color: #4f97d7; font-weight: bold;">else</span>            LockSupport.park<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span><span style="color: #2d9574;">)</span>;    <span style="color: #bc6ec5;">}</span><span style="color: #4f97d7;">}</span></pre></div></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;
由于FutureTask可能在多个线程中触发执行或者取消逻辑,如果没有线程安全保证，
可能会出现执行已取消操作，异步操作被多次执行等违反Futuretask语义的情形。
为了保证FutureTask的线程安全，jdk结合使用了状态机和cas操作。
&lt;/p&gt;
&lt;div id
      
    
    </summary>
    
      <category term="java" scheme="http://summerisgreen.com/categories/java/"/>
    
    
      <category term="java" scheme="http://summerisgreen.com/tags/java/"/>
    
      <category term="源码" scheme="http://summerisgreen.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop中的Mapper和Reducer数量设定</title>
    <link href="http://summerisgreen.com/blog/2018-04-24-2018-04-23-hadoop%E4%B8%ADmapper%E5%92%8Creducer%E4%B8%AA%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE.html"/>
    <id>http://summerisgreen.com/blog/2018-04-24-2018-04-23-hadoop中mapper和reducer个数的设置.html</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2019-03-14T23:44:27.337Z</updated>
    
    <content type="html"><![CDATA[<p>对于大数据处理，特别是T级别以上的海量数据，由于数据量大大超过了单机运算能力，需要通过分布式的方法来对数据进行处理。Hadoop作为大数据领域的明星项目，提供了MapReduce分布式编程框架,其基于分而治冶的思想，将海量数据拆分为大量的小数据块，从而在多个节点并行处理海量数据。</p><p>虽然MapReduce通过分布式计算、map端"数据本地化优化“等不同层次的策略来提升数据处理任务的执行效率，但由于实际处理的数据量较大，一个典型的MapReduce作业往往需要花费数分钟到数小时来完成。并且在任务执行的过程中，MapReduce作业还将占用大量的网络带宽和计算资源，从而降低了整个集群的计算能力。为了进一步提升MapReduce的执行效率，需要对MapReduce任务进行调优。而最为直接有效的一种调优方式就是调整Mapper和Reducer的数量。</p><div id="outline-container-org822556c" class="outline-2"><h2 id="org822556c">Mapper的数量设定</h2><div class="outline-text-2" id="text-org822556c"><p>在对Mapper调优的过程中，一个经验法则是：map任务最好拥有一分钟以上的运行时间。因为如果任务运行时间过短，将导致在整个作业的执行过程中任务启动所花费的时间过大，从而降低了实际的任务执行效率。对map任务的运行时间影响最大的是Mapper的个数，不过与Reducer不同，Mapper的个数是无法显示指定的。调节Mapper数量的一种方式是设置参数mapred.jobtracker.maxtasks.per.job，但其只能限制每个job中并发运行的map或reduce任务的上限，而当实际运行的map数低于该上限时，该参数将失效。如果想要对Mapper个数进行更加直接有效的控制，需要指定输入数据的分片大小。</p><p>输入分片(input split)是MapReduce框架为使map任务能并行处理海量数据记录，为每个map任务单独划分的一个等长小数据块。在MapReduce框架中，输入数据分片通过InputFormat接口完成。为方便程序员使用，Hadoop为最常见的文件数据源提供了大量基于FileInputFormat基类的实现类。因此只要掌握了FileInputFormat的数据分片原理，也就知道了各种常见的数据源实现类是如何进行数据分片的了。</p><p>FileInputFormat提供了三个属性参数来控制实际的分片大小：mapreduce.input.fileinputformat.split.minsize, mapreduce.input.fileinputformat.split.maxsize以及dfs.blocksize。这三个参数分别表示一个文件分片最小的有效字节数、最大字节数以及HDFS中块的大小。利用公式splitSize = max(minimumSize, min(maximumSize, blockSize))，可以通过改变上述三个参数来调节最终的分片大小。在调节分片大小时需要防止分片切分过小，避免管理分片和构建map任务的时间在整个任务运行周期中占比过大。但分片划分也不是越大越好，至少不应大于块大小，因为那时将无法确保存储有该切片的多个数据块位于单个节点中，从而增加了执行map任务时的网络传输。因此对于大多数作业来说，一个合理的分片大小趋向于HDFS的一个块的大小，默认是128MB。</p><p>需要注意的是，虽然输入分片划分是本着尽量拆分成等长数据块的原则，但最后的分片大小并不完全一致。因为数据分片对有效字节数小于maximumSize的文件并不进行拆分，而且进行拆分的大文件的大小往往不会为文件块大小的整数倍。分片大小与指向分片数据的引用一起包含在输入分片中，供application master调度使用。在调度的过程中，Hadoop通过优先处理最大的分片以最小化实际运行时间。</p></div></div><div id="outline-container-org1dd2598" class="outline-2"><h2 id="org1dd2598">Reducer的数量设定</h2><div class="outline-text-2" id="text-org1dd2598"><p>Reducer的个数是由用户独立设置的，在默认情况下只有一个Reducer。它的个数既可以使用命令行参数设置（mapreduce.job.reduces=number），也可以在程序中制定（job.setNumReduceTasks(number)）。</p><p>为了更加高效地完成reduce任务，Reducer的个数需要依据自己的任务特点和机器负载情况进行选择。Hadoop权威指南给出的一条经验法则是：目标Reducer保持在每个运行5分钟左右，且产生至少一个HDFS块的输出。而Apache的MapReduce官方教程中给出的建议是：Reducer个数应该设置为0.95或者1.75乘以节点数与每个节点的容器数的乘积。当乘数为0.95时，map任务结束后所有的reduce将会立刻启动并开始转移数据，此时队列中无等待任务，该设置适合reudce任务执行时间短或者reduce任务在个节点的执行时间相差不大的情况；当乘数为1.75时，运行较快的节点将在完成第一轮reduce任务后，可以立即从队列中取出新的reduce任务执行，由于该reduce个数设置方法减轻了单个reduce任务的负载，并且运行较快的节点将执行新的reduce任务而非空等执行较慢的节点，其拥有更好的负载均衡特性。</p></div></div><div id="outline-container-orgb4af80d" class="outline-2"><h2 id="orgb4af80d">参考</h2><div class="outline-text-2" id="text-orgb4af80d"><p><a href="https://book.douban.com/subject/27115351/" target="_blank" rel="noopener">Hadoop权威指南</a></p><p><a href="https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html#Reducer" target="_blank" rel="noopener">MapReduce Tutorial</a></p><p><a href="https://stackoverflow.com/questions/21980110/what-is-ideal-number-of-reducers-on-hadoop" target="_blank" rel="noopener">What is Ideal number of reducers on Hadoop?</a></p><p><a href="https://stackoverflow.com/questions/20818370/how-to-set-the-number-of-mappers-in-new-hadoop-api" target="_blank" rel="noopener">How to set the number of mappers in new Hadoop api?</a></p></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;
对于大数据处理，特别是T级别以上的海量数据，
由于数据量大大超过了单机运算能力，需要通过分布式的方法来对数据进行处理。
Hadoop作为大数据领域的明星项目，提供了MapReduce分布式编程框架,
其基于分而治冶的思想，将海量数据拆分为大量的小数据块，从而在多个节点并行
      
    
    </summary>
    
      <category term="大数据" scheme="http://summerisgreen.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://summerisgreen.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://summerisgreen.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>算法技巧-使用动态规划求解部分和问题</title>
    <link href="http://summerisgreen.com/blog/2017-07-28-2017-07-28-%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E8%A7%A3%E9%83%A8%E5%88%86%E5%92%8C%E9%97%AE%E9%A2%98.html"/>
    <id>http://summerisgreen.com/blog/2017-07-28-2017-07-28-算法技巧-使用动态规划求解部分和问题.html</id>
    <published>2017-07-27T16:00:00.000Z</published>
    <updated>2019-03-14T23:44:29.410Z</updated>
    
    <content type="html"><![CDATA[<div id="outline-container-org58b574a" class="outline-2"><h2 id="org58b574a">部分和问题</h2><div class="outline-text-2" id="text-org58b574a"><p>在算法中，有一类常见的问题被称为部分和问题。在这类问题中，你需要判断是否能够使用给定数组中的部分数，通过累加获得所要获得的目标和。而对于每个候选数字，在有些题目中你只能使用一次，而在另一些题目中则可以多次使用。在后面我们会看到，这两种情况都可以使用动态规划方法来求解，只不过具体的求解思路会有一些不同。</p></div></div><div id="outline-container-orgb0ee185" class="outline-2"><h2 id="orgb0ee185">Partition Equal Subset Sum</h2><div class="outline-text-2" id="text-orgb0ee185"><pre class="example">Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</pre><p>为了解决这个问题，首先假设我们将集合 nums 分成了满足条件的 A 和 B 这两个子集合，它们必然满足下面两个条件：</p><p>sum(A) = sum(B)sum(A) + sum(B) = sum(nums)</p><p>使用前一个公式将后一个等式中的B替换为A，可得：</p><p>sum(A) = sum(nums)/2 </p><p>我们可以发现，这道题已经转化成了我们之前所讨论的部分和的问题了。</p><p>现在我们所要求解的是：是否能够从一个给定的数的集合选出一个子集合，这个子集合中元素的和为该集合中全部元素和的一半。当然如果整个集合中所有元素的和为奇数的话，这个子集合肯定不存在。可以对这个条件提前进行判断，以减少不必要的计算。</p><p>如果整个集合中所有元素的和的一半为偶数的话，就需要使用动态规划方法来判断是否能够找到这样的子集合。为了使用动态规划方法，我们构造了一个数组称为 oldp，其表示对于已经遍历过的数字，是否能在它们中找到所有元素的和等于该索引值的子集合。</p><ul class="org-ul"><li>初始化：在第一次迭代之前，只有索引为0的位置的值为True，其余均为False，条件为真。</li><li>保持：当遍历第i个数时，当且仅当j之前就能被部分和所表示或者j-i能被表示时，该遍历完成后j能被表示。</li><li>终止：oldp 中各个索引的值表示是否能用所给的数组的部分和来表示。</li></ul><p>因此在完成所有数值的循环后，只需要查看索引为 half 的 oldp 即可知道是否能将整个数组分为两个元素和相等的集合。</p><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">canPartition</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span>, nums<span style="color: #4f97d7;">)</span>:    <span style="color: #2aa1ae;">"""</span><span style="color: #2aa1ae;">    :type nums: List[int]</span><span style="color: #2aa1ae;">    :rtype: bool</span><span style="color: #2aa1ae;">    """</span>    <span style="color: #7590db;">sums</span> = <span style="color: #4f97d7;">sum</span><span style="color: #4f97d7;">(</span>nums<span style="color: #4f97d7;">)</span>    <span style="color: #4f97d7; font-weight: bold;">if</span> sums % <span style="color: #a45bad;">2</span> == <span style="color: #a45bad;">1</span>:        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">False</span>    <span style="color: #7590db;">half</span> = sums / <span style="color: #a45bad;">2</span>    <span style="color: #7590db;">oldp</span> = <span style="color: #4f97d7;">[</span><span style="color: #a45bad;">False</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>half + <span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">oldp</span><span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> = <span style="color: #a45bad;">True</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> nums:        <span style="color: #4f97d7; font-weight: bold;">for</span> j <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span>half, i-<span style="color: #a45bad;">1</span>, -<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>:            <span style="color: #7590db;">oldp</span><span style="color: #4f97d7;">[</span>j<span style="color: #4f97d7;">]</span> = oldp<span style="color: #4f97d7;">[</span>j<span style="color: #4f97d7;">]</span> <span style="color: #4f97d7; font-weight: bold;">or</span> oldp<span style="color: #4f97d7;">[</span>j-i<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> oldp<span style="color: #4f97d7;">[</span>half<span style="color: #4f97d7;">]</span></pre></div></div></div><div id="outline-container-org8bd4520" class="outline-2"><h2 id="org8bd4520">Target Sum</h2><div class="outline-text-2" id="text-org8bd4520"><pre class="example"> You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.Find out how many ways to assign symbols to make sum of integers equal to target S. </pre><p>这道题目看起来和上一个题目相差很大，但是如果我们对题目所给的条件做一些适当的数学变化的话，就会发现这道题目本质上也是个部分和的问题。</p><p>首先我们假设在这个集合中，正的子集合为P，负的为N。然后我们就可以使用这两个符号将题目所包含的关系给表示出来：</p><p>sum(P) + sum(N) = sum(nums)</p><p>sum(P) - sum(N) = S</p><p>将这两个等式组合一下之后，我们可以发现该问题已经转换为部分和的问题了:</p><p>sum(P) = (sum(nums) + S)/2</p><p>这里一个比较大的不同就是：这个问题所求的是有多少种不同的部分和的结果和目标值相同，而上一题仅仅需要知道是否存在和目标值的部分和。所以在这里，我们的 dp 表示的是存在多少种不同的部分和可以表示该索引值，此时的内层递推公式也相应的改成了:</p><p>dp[j] += dp[j-1]</p><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">findTargetSumWays</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span>, nums, S<span style="color: #4f97d7;">)</span>:    <span style="color: #2aa1ae;">"""</span><span style="color: #2aa1ae;">    :type nums: List[int]</span><span style="color: #2aa1ae;">    :type S: int</span><span style="color: #2aa1ae;">    :rtype: int</span><span style="color: #2aa1ae;">    """</span>    <span style="color: #7590db;">target</span> = <span style="color: #4f97d7;">sum</span><span style="color: #4f97d7;">(</span>nums<span style="color: #4f97d7;">)</span> + S    <span style="color: #4f97d7; font-weight: bold;">if</span> S &gt; <span style="color: #4f97d7;">sum</span><span style="color: #4f97d7;">(</span>nums<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">or</span> target % <span style="color: #a45bad;">2</span>:        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">0</span>    <span style="color: #4f97d7; font-weight: bold;">else</span>:        <span style="color: #7590db;">target</span> = target/<span style="color: #a45bad;">2</span>    <span style="color: #7590db;">dp</span> = <span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>target+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">dp</span><span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> = <span style="color: #a45bad;">1</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> nums:        <span style="color: #4f97d7; font-weight: bold;">for</span> j <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">reversed</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7;">range</span><span style="color: #bc6ec5;">(</span>i, target+<span style="color: #a45bad;">1</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>:            <span style="color: #7590db;">dp</span><span style="color: #4f97d7;">[</span>j<span style="color: #4f97d7;">]</span> += dp<span style="color: #4f97d7;">[</span>j-i<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> dp<span style="color: #4f97d7;">[</span>target<span style="color: #4f97d7;">]</span></pre></div></div></div><div id="outline-container-orgf2a13b6" class="outline-2"><h2 id="orgf2a13b6">Combination Sum IV</h2><div class="outline-text-2" id="text-orgf2a13b6"><pre class="example">Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</pre><p>需要注意的是，在这个题目中数组中的每个数字都可以使用多次，而不是像之前的题目所要求的只能使用一次。为了能够满足这个条件，我们可以从1开始一直到目标值，依次尝试是否能够使用数组中的数来累加到所尝试的索引值。因为数组中的数是大于等于1的，而我们对部分和目标值的搜索跨度为1，所以使用这种方法必定是不会错过数组集合中所有数值的任何一种可能的组合的。</p><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">combinationSum4</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span>, nums, target<span style="color: #4f97d7;">)</span>:    <span style="color: #2aa1ae;">"""</span><span style="color: #2aa1ae;">    :type nums: List[int]</span><span style="color: #2aa1ae;">    :type target: int</span><span style="color: #2aa1ae;">    :rtype: int</span><span style="color: #2aa1ae;">    """</span>    <span style="color: #7590db;">d</span> = <span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>target+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">d</span><span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> = <span style="color: #a45bad;">1</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span>,target+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">for</span> j <span style="color: #4f97d7; font-weight: bold;">in</span> nums:            <span style="color: #4f97d7; font-weight: bold;">if</span> i &gt;= j:                <span style="color: #7590db;">d</span><span style="color: #4f97d7;">[</span>i<span style="color: #4f97d7;">]</span> += d<span style="color: #4f97d7;">[</span>i-j<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> d<span style="color: #4f97d7;">[</span>target<span style="color: #4f97d7;">]</span></pre></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        
&lt;div id=&quot;outline-container-org58b574a&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;org58b574a&quot;&gt;部分和问题&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-org58b574a&quot;&gt;

      
    
    </summary>
    
      <category term="编程技巧" scheme="http://summerisgreen.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="编程技巧" scheme="http://summerisgreen.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
      <category term="算法" scheme="http://summerisgreen.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法技巧-使用动态规划解决地图路径类问题</title>
    <link href="http://summerisgreen.com/blog/2017-07-27-2017-07-27-%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E5%9C%B0%E5%9B%BE%E8%B7%AF%E5%BE%84%E7%B1%BB%E9%97%AE%E9%A2%98.html"/>
    <id>http://summerisgreen.com/blog/2017-07-27-2017-07-27-算法技巧-使用动态规划解决地图路径类问题.html</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2019-03-14T23:44:26.930Z</updated>
    
    <content type="html"><![CDATA[<div id="outline-container-orgb79ee36" class="outline-2"><h2 id="orgb79ee36">栅格化的有向图类问题</h2><div class="outline-text-2" id="text-orgb79ee36"><p>对于图论的路径寻找问题，比较经典的解法就是Dijkstra 和 A*算法了。这两种方法虽然通用，但编码实现比较复杂。如果对这类问题中比较简单的一些问题也采用这种解法的话，就有点用大炮打蚊子的感觉了。</p><p>这里面的一类简单问题就是在栅格化了的有向图中进行搜索，因为其探索路径比较固定，一般为向右和向下，所以可以直接使用动态规划来进行求解。</p><p>下面将结合leetcode题目来进行具体的讲解。</p></div></div><div id="outline-container-orge99b09f" class="outline-2"><h2 id="orge99b09f">Minimum Path Sum</h2><div class="outline-text-2" id="text-orge99b09f"><pre class="example">Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</pre><p>对于最短路径问题，假设我们有一个 m*n 的cost矩阵，这个矩阵中每个点表示的是从起始点到该点的最小路径的值。矩阵中值的迭代过程可以使用下面的公式来表示：</p><p>cost(i,j) = min(cost(i-1,j), cost(i,j-1)) + grid[i][j]。</p><p>有了这个迭代公式，我们就可以使用动态规划方法来求解这个最短路径的问题了。</p><p>在编码之前，我们通过观察可以发现，在实际计算cost时，我们只需要当前行中的前一列中的元素和前一行中当前列的元素，因此我们实际需要的只是两个n维向量而不是 m*n 的矩阵。我们将这两个向量命名为 pre 和 cur，它们分别表示前一行和当前行向量。利用这两个向量，我们将之前的迭代公式转化为：</p><p>cur(j) = min(cur(j-1),pre(j)) + grid[i][j]。</p><p>在编码求解该问题的过程中，一个比较麻烦的细节就是对边界问题的处理了。可以使用的一个技巧就是给这两个向量的头部增加一个节点作为哨兵节点。这里将 cur 的第一个节点设置为正无穷大，保证最左端的节点只会采用从前一行过来的路径。而第一行需要特殊处理，因为他们都只存在从左边过来的路径，这里将 pre 的第一个元素设置为0，从而保证了元素值的正确性。</p><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">minPathSum</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span>, grid<span style="color: #4f97d7;">)</span>:    <span style="color: #2aa1ae;">"""</span><span style="color: #2aa1ae;">    :type grid: List[List[int]]</span><span style="color: #2aa1ae;">    :rtype: int</span><span style="color: #2aa1ae;">    """</span>    <span style="color: #7590db;">height</span>, <span style="color: #7590db;">length</span> = <span style="color: #4f97d7;">len</span><span style="color: #4f97d7;">(</span>grid<span style="color: #4f97d7;">)</span>, <span style="color: #4f97d7;">len</span><span style="color: #4f97d7;">(</span>grid<span style="color: #bc6ec5;">[</span><span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">pre</span> = <span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>length+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">cur</span> = <span style="color: #4f97d7;">[</span><span style="color: #4f97d7;">float</span><span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">"inf"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>length+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span>length<span style="color: #4f97d7;">)</span>:        <span style="color: #7590db;">pre</span><span style="color: #4f97d7;">[</span>i+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span> = pre<span style="color: #4f97d7;">[</span>i<span style="color: #4f97d7;">]</span> + grid<span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">][</span>i<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span>, height<span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">for</span> j <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span>length<span style="color: #4f97d7;">)</span>:            <span style="color: #7590db;">cur</span><span style="color: #4f97d7;">[</span>j+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span> = <span style="color: #4f97d7;">min</span><span style="color: #4f97d7;">(</span>cur<span style="color: #bc6ec5;">[</span>j<span style="color: #bc6ec5;">]</span>, pre<span style="color: #bc6ec5;">[</span>j+<span style="color: #a45bad;">1</span><span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span> + grid<span style="color: #4f97d7;">[</span>i<span style="color: #4f97d7;">][</span>j<span style="color: #4f97d7;">]</span>        <span style="color: #7590db;">pre</span> = <span style="color: #4f97d7;">[</span>i <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> cur<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> pre<span style="color: #4f97d7;">[</span>length<span style="color: #4f97d7;">]</span></pre></div></div></div><div id="outline-container-org162a277" class="outline-2"><h2 id="org162a277">Unique Paths</h2><div class="outline-text-2" id="text-org162a277"><pre class="example">A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).How many possible unique paths are there?</pre><p>这个问题的基本迭代公式为 paths(i,j) = paths(i-1,j) + paths(i,j-1)，其解决思路和上一题的一致，只是初始化和边界条件的设置更加简单。</p><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">uniquePaths</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span>, m, n<span style="color: #4f97d7;">)</span>:    <span style="color: #2aa1ae;">"""</span><span style="color: #2aa1ae;">    :type m: int</span><span style="color: #2aa1ae;">    :type n: int</span><span style="color: #2aa1ae;">    :rtype: int</span><span style="color: #2aa1ae;">    """</span>    <span style="color: #7590db;">pre</span> = <span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>n+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">cur</span> = <span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>n+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> j <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span>n<span style="color: #4f97d7;">)</span>:        <span style="color: #7590db;">pre</span><span style="color: #4f97d7;">[</span>j+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span> = <span style="color: #a45bad;">1</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span>,m<span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">for</span> j <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span>n<span style="color: #4f97d7;">)</span>:            <span style="color: #7590db;">cur</span><span style="color: #4f97d7;">[</span>j+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span> = cur<span style="color: #4f97d7;">[</span>j<span style="color: #4f97d7;">]</span> + pre<span style="color: #4f97d7;">[</span>j+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span>        <span style="color: #7590db;">pre</span> = <span style="color: #4f97d7;">[</span>mem <span style="color: #4f97d7; font-weight: bold;">for</span> mem <span style="color: #4f97d7; font-weight: bold;">in</span> cur<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> pre<span style="color: #4f97d7;">[</span>n<span style="color: #4f97d7;">]</span></pre></div></div></div><div id="outline-container-orga2cedc1" class="outline-2"><h2 id="orga2cedc1">Unique Paths II</h2><div class="outline-text-2" id="text-orga2cedc1"><pre class="example">Follow up for "Unique Paths":Now consider if some obstacles are added to the grids. How many unique paths would there be?An obstacle and empty space is marked as 1 and 0 respectively in the grid.</pre><p>如果路径中是存在障碍物的话，基本思路和之前的题目依旧相同，只是要在每个迭代中加一个将障碍物点上的路径值设为0的语句即可。具体的解法如下面的Python代码所示。</p><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">uniquePathsWithObstacles</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span>, obstacleGrid<span style="color: #4f97d7;">)</span>:    <span style="color: #2aa1ae;">"""</span><span style="color: #2aa1ae;">    :type obstacleGrid: List[List[int]]</span><span style="color: #2aa1ae;">    :rtype: int</span><span style="color: #2aa1ae;">    """</span>    <span style="color: #7590db;">height</span>, <span style="color: #7590db;">length</span> = <span style="color: #4f97d7;">len</span><span style="color: #4f97d7;">(</span>obstacleGrid<span style="color: #4f97d7;">)</span>, <span style="color: #4f97d7;">len</span><span style="color: #4f97d7;">(</span>obstacleGrid<span style="color: #bc6ec5;">[</span><span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">pre</span> = <span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>length +<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">cur</span> = <span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> * <span style="color: #4f97d7;">(</span>length +<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>    <span style="color: #7590db;">pre</span><span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">]</span> = <span style="color: #a45bad;">1</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span>length<span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">if</span> obstacleGrid<span style="color: #4f97d7;">[</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">][</span>i<span style="color: #4f97d7;">]</span> == <span style="color: #a45bad;">1</span>:            <span style="color: #7590db;">pre</span><span style="color: #4f97d7;">[</span>i+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span> = <span style="color: #a45bad;">0</span>        <span style="color: #4f97d7; font-weight: bold;">else</span>:            <span style="color: #7590db;">pre</span><span style="color: #4f97d7;">[</span>i+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span> = pre<span style="color: #4f97d7;">[</span>i<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span>, height<span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">for</span> j <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span>length<span style="color: #4f97d7;">)</span>:            <span style="color: #4f97d7; font-weight: bold;">if</span> obstacleGrid<span style="color: #4f97d7;">[</span>i<span style="color: #4f97d7;">][</span>j<span style="color: #4f97d7;">]</span> == <span style="color: #a45bad;">1</span>:                <span style="color: #7590db;">cur</span><span style="color: #4f97d7;">[</span>j+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span> = <span style="color: #a45bad;">0</span>            <span style="color: #4f97d7; font-weight: bold;">else</span>:                <span style="color: #7590db;">cur</span><span style="color: #4f97d7;">[</span>j+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span> = cur<span style="color: #4f97d7;">[</span>j<span style="color: #4f97d7;">]</span> + pre<span style="color: #4f97d7;">[</span>j+<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span>        <span style="color: #7590db;">pre</span> = <span style="color: #4f97d7;">[</span>i <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> cur<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> pre<span style="color: #4f97d7;">[</span>-<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span></pre></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        
&lt;div id=&quot;outline-container-orgb79ee36&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;orgb79ee36&quot;&gt;栅格化的有向图类问题&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-orgb79ee
      
    
    </summary>
    
      <category term="编程技巧" scheme="http://summerisgreen.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="编程技巧" scheme="http://summerisgreen.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
      <category term="算法" scheme="http://summerisgreen.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法技巧-backtracking</title>
    <link href="http://summerisgreen.com/blog/2017-07-07-2017-07-07-%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7-backtracking.html"/>
    <id>http://summerisgreen.com/blog/2017-07-07-2017-07-07-算法技巧-backtracking.html</id>
    <published>2017-07-06T16:00:00.000Z</published>
    <updated>2019-03-14T23:44:27.683Z</updated>
    
    <content type="html"><![CDATA[<div id="outline-container-orga9a49c9" class="outline-2"><h2 id="orga9a49c9">Backtracking 算法</h2><div class="outline-text-2" id="text-orga9a49c9"><p>Backtracking（回溯)法是一个实用性非常强的算法，它的核心思想正如其名字所蕴含的意思：沿着之前走的路退回到上一个岔路口，然后选择另一条路继续探索。除了回溯思想之外，该算法的另一个关键就是对何时进行回溯，何时结束算法进行判断，而对这个的具体实现又是和所遇到的问题相关联。</p><p>将这两个关键点结合起来之后，我们可以得到回溯算法的一个非形式化的描述：在搜索过程中，按照自定义的规则在遭遇的分支中进行选择；当所选择的分支为不可行(或者已被完全搜索时)，退回到上一个分支的分叉点，并在未被选取过的分支中选择一个，然后继续搜索。</p><p>回溯算法不仅原理简单，而且应用十分广泛。该算法最常见的一种变体就是十分有名的在图或树中寻找可行解的深度优先搜索算法(Depth First Search)。</p><p>回溯算法算法应用广泛的一个原因就是其可以针对不同形式的解来做适当的变形，以进行求解。回溯算法对于具有不同解的形式的问题的求解思路将在下面一一介绍。</p></div></div><div id="outline-container-org505664d" class="outline-2"><h2 id="org505664d">回溯算法的应用</h2><div class="outline-text-2" id="text-org505664d"><p>在对回溯算法的实际编码过程中，由于递归调用的存在，可以很优雅的方式将回溯算法表示出来，而不需要实现复杂的回撤操作。</p><p>回溯算法最常见的应用是用来在有限的搜索集中寻找下面三种形式的解：</p><ul class="org-ul"><li>可行解</li><li>最优解</li><li>所有解</li></ul><p>对于前两类问题，它们的问题形式比较固定，其求解过程直接套用下面介绍的思路即可。而对查找所有可行解的问题，由于通常会需要去除冗余解并对求解过程进行加速，需要针对具体的需求进行适当的变形。</p></div><div id="outline-container-orga67a304" class="outline-3"><h3 id="orga67a304">可行解思路</h3><div class="outline-text-3" id="text-orga67a304"><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">solve</span><span style="color: #4f97d7;">(</span>node, path<span style="color: #4f97d7;">)</span>:    <span style="color: #7590db;">path</span> += <span style="color: #4f97d7;">[</span>node<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">if</span> leave?<span style="color: #4f97d7;">(</span>node<span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">return</span> path <span style="color: #4f97d7; font-weight: bold;">if</span> satisfy?<span style="color: #4f97d7;">(</span>path<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #a45bad;">None</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> c <span style="color: #4f97d7; font-weight: bold;">in</span> choice<span style="color: #4f97d7;">(</span>node<span style="color: #4f97d7;">)</span>:        <span style="color: #7590db;">ans</span> = solve<span style="color: #4f97d7;">(</span>c, path<span style="color: #4f97d7;">)</span>        <span style="color: #4f97d7; font-weight: bold;">if</span> ans <span style="color: #4f97d7; font-weight: bold;">is</span> <span style="color: #4f97d7; font-weight: bold;">not</span> <span style="color: #a45bad;">None</span>:            <span style="color: #4f97d7; font-weight: bold;">return</span> ans    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">None</span></pre></div></div></div><div id="outline-container-orgf86fa90" class="outline-3"><h3 id="orgf86fa90">最优解思路</h3><div class="outline-text-3" id="text-orgf86fa90"><div class="org-src-container"><pre class="src src-python"><span style="color: #7590db;">best</span> = -<span style="color: #4f97d7;">float</span><span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"inf"</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">find_best</span><span style="color: #4f97d7;">(</span>node, path<span style="color: #4f97d7;">)</span>:    <span style="color: #7590db;">path</span> += <span style="color: #4f97d7;">[</span>node<span style="color: #4f97d7;">]</span>    <span style="color: #4f97d7; font-weight: bold;">if</span> leave?<span style="color: #4f97d7;">(</span>node<span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">if</span> satisfy?<span style="color: #4f97d7;">(</span>path<span style="color: #4f97d7;">)</span>:            <span style="color: #7590db;">best</span> = <span style="color: #4f97d7;">max</span><span style="color: #4f97d7;">(</span>best, score<span style="color: #bc6ec5;">(</span>node<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>        <span style="color: #4f97d7; font-weight: bold;">return</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> c <span style="color: #4f97d7; font-weight: bold;">in</span> choice<span style="color: #4f97d7;">(</span>node<span style="color: #4f97d7;">)</span>:        find_best<span style="color: #4f97d7;">(</span>c, path<span style="color: #4f97d7;">)</span></pre></div></div></div><div id="outline-container-org6b70b77" class="outline-3"><h3 id="org6b70b77">寻找存在的所有解</h3><div class="outline-text-3" id="text-org6b70b77"><div class="org-src-container"><pre class="src src-python"><span style="color: #7590db;">ans</span> = <span style="color: #4f97d7;">[]</span><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">find_all</span><span style="color: #4f97d7;">(</span>node, path<span style="color: #4f97d7;">)</span>:    <span style="color: #7590db;">path</span> += node    <span style="color: #4f97d7; font-weight: bold;">if</span> leave?<span style="color: #4f97d7;">(</span>node<span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">if</span> satisfy?<span style="color: #4f97d7;">(</span>path<span style="color: #4f97d7;">)</span>:            <span style="color: #7590db;">ans</span> += path        <span style="color: #4f97d7; font-weight: bold;">return</span>    <span style="color: #4f97d7; font-weight: bold;">for</span> c <span style="color: #4f97d7; font-weight: bold;">in</span> choice<span style="color: #4f97d7;">(</span>node<span style="color: #4f97d7;">)</span>:        find_all<span style="color: #4f97d7;">(</span>c, path<span style="color: #4f97d7;">)</span></pre></div><p>对于寻找存在的所有解的问题，一般不仅需要找到所有解，还要求找到的解不能重复;为了满足这个需求需要增加一些额外的操作，具体将结合下面这个来自 leetcode 的题目进行说明。</p></div><div id="outline-container-orgcadb8c7" class="outline-4"><h4 id="orgcadb8c7">Combination Sum II</h4><div class="outline-text-4" id="text-orgcadb8c7"><pre class="example">Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.Each number in C may only be used once in the combination. </pre><p>该题目的难点就是如何高效地找出所有不重复的结果。</p><p>首先需要做的是对整个原始数据进行排序，因为这用可以方便后面过滤掉重复的结果，并且可以使得后续的运算时间减少一个常数因子（为之前的几分之一）。而这个方法对整个程序的时间效率的影响不大，对候选对象的排序的时间复杂度为 O(n * lg(n))和整个搜索过程的时间复杂度(O(n^2))不是一个量级上的。</p><p>在之前的解算思路上还添加了 e &lt;= target and (i &lt; 1 or candidates[i] != candidates[i-1]) 这个判定条件。这个条件的前面部分减少了搜索的计算量，后面部分则在当前分叉点上跳过与之前相同的选择保证了搜索结果的不重复。</p><p>搜索结果的不重复性可以通过对递归式 csIter 进行循环不变式分析来证明。</p><ul class="org-ul"><li>循环不变式：相同长度的 comb ，其值不相同。</li><li>初始化：第一次迭代之前，长度为0的 comb，不包含任何值。成立。</li><li>保持：假设当 comb 中元素个数为 n 时，之前计算出的 comb 不重复，对于满足条件 i &lt; 1 or candidates[i] != candidates[i-1] 的结果，其添加的新元素能保证新的 comb 不重复。因此完成此步添加操作的 comb不会产生重复。</li><li>终止：当循环终止时，长度相同的 comb 中的值不同。</li></ul><p>所以对于最终结果中的解，不是不同的长度的值，要不就是相同的长度但不重复的值，所以其结果必然不重复。</p><p>看了上面的推理，对于重复性的问题应该是解决了，但是可能会引发另一个担忧：过滤掉了这些条件，会不会导致最终的结果不完整。为了消除这个疑虑，只要证明过滤掉的搜索结果都是在现有结果中已有的即可。对于去除的元素，其满足下面的条件：i &gt; 0 并且 candidates[i] == candidates[i-1]。也就是说去除的潜在对象是作为新符合条件的候选项，已经在子程序中添加过到 comb 中的。而当前的 comb 和前一个潜在对象的时候相同，并且当前的潜在对象是之前的潜在对象的子集，因此该条件下产生的结果是之前的结果的子集。所有过滤掉判定条件之后的结果依然是完整的。</p><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">combinationSum2</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span>, candidates, target<span style="color: #4f97d7;">)</span>:    <span style="color: #2aa1ae;">"""</span><span style="color: #2aa1ae;">    :type candidates: List[int]</span><span style="color: #2aa1ae;">    :type target: int</span><span style="color: #2aa1ae;">    :rtype: List[List[int]]</span><span style="color: #2aa1ae;">    """</span>    <span style="color: #7590db;">ans</span> = <span style="color: #4f97d7;">[]</span>    <span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">csIter</span><span style="color: #4f97d7;">(</span>candidates, target, comb<span style="color: #4f97d7;">)</span>:        <span style="color: #4f97d7; font-weight: bold;">if</span> target == <span style="color: #a45bad;">0</span>:            ans.append<span style="color: #4f97d7;">(</span><span style="color: #bc6ec5;">[</span>i <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> comb<span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>        <span style="color: #4f97d7; font-weight: bold;">for</span> i, e <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">enumerate</span><span style="color: #4f97d7;">(</span>candidates<span style="color: #4f97d7;">)</span>:            <span style="color: #4f97d7; font-weight: bold;">if</span> e &lt;= target <span style="color: #4f97d7; font-weight: bold;">and</span> <span style="color: #4f97d7;">(</span>i &lt; <span style="color: #a45bad;">1</span> <span style="color: #4f97d7; font-weight: bold;">or</span> candidates<span style="color: #bc6ec5;">[</span>i<span style="color: #bc6ec5;">]</span> != candidates<span style="color: #bc6ec5;">[</span>i-<span style="color: #a45bad;">1</span><span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>:                comb.append<span style="color: #4f97d7;">(</span>e<span style="color: #4f97d7;">)</span>                csIter<span style="color: #4f97d7;">(</span>candidates<span style="color: #bc6ec5;">[</span>i+<span style="color: #a45bad;">1</span>:<span style="color: #bc6ec5;">]</span>, target-e, comb<span style="color: #4f97d7;">)</span>                comb.pop<span style="color: #4f97d7;">()</span>    csIter<span style="color: #4f97d7;">(</span><span style="color: #4f97d7;">sorted</span><span style="color: #bc6ec5;">(</span>candidates<span style="color: #bc6ec5;">)</span>, target, <span style="color: #bc6ec5;">[]</span><span style="color: #4f97d7;">)</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> ans</pre></div><p>在 leetcode 上的另一个中档难度的题可以采用和本题相同的技巧来解决，其问题及解法如下所示。</p></div></div><div id="outline-container-orgf3b6533" class="outline-4"><h4 id="orgf3b6533">Subsets II</h4><div class="outline-text-4" id="text-orgf3b6533"><pre class="example">Given a collection of integers that might contain duplicates, nums, return all possible subsets. </pre><p>该题目除了没有了 target 目标的约束之外，和之前的题目类似。在实际求解的过程中，只要将之前的解放中和 target 相关的表达式删去即可。</p><div class="org-src-container"><pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">subsetsWithDup</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span>, nums<span style="color: #4f97d7;">)</span>:    <span style="color: #2aa1ae;">"""</span><span style="color: #2aa1ae;">    :type nums: List[int]</span><span style="color: #2aa1ae;">    :rtype: List[List[int]]</span><span style="color: #2aa1ae;">    """</span>    <span style="color: #7590db;">ans</span> = <span style="color: #4f97d7;">[]</span>    <span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">swdIter</span><span style="color: #4f97d7;">(</span>candidates, comb<span style="color: #4f97d7;">)</span>:        ans.append<span style="color: #4f97d7;">(</span><span style="color: #bc6ec5;">[</span>i <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> comb<span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>        <span style="color: #4f97d7; font-weight: bold;">for</span> i, e <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">enumerate</span><span style="color: #4f97d7;">(</span>candidates<span style="color: #4f97d7;">)</span>:            <span style="color: #4f97d7; font-weight: bold;">if</span> i &lt; <span style="color: #a45bad;">1</span> <span style="color: #4f97d7; font-weight: bold;">or</span> candidates<span style="color: #4f97d7;">[</span>i<span style="color: #4f97d7;">]</span> != candidates<span style="color: #4f97d7;">[</span>i-<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">]</span>:                comb.append<span style="color: #4f97d7;">(</span>e<span style="color: #4f97d7;">)</span>                swdIter<span style="color: #4f97d7;">(</span>candidates<span style="color: #bc6ec5;">[</span>i+<span style="color: #a45bad;">1</span>:<span style="color: #bc6ec5;">]</span>, comb<span style="color: #4f97d7;">)</span>                comb.pop<span style="color: #4f97d7;">()</span>    swdIter<span style="color: #4f97d7;">(</span><span style="color: #4f97d7;">sorted</span><span style="color: #bc6ec5;">(</span>nums<span style="color: #bc6ec5;">)</span>, <span style="color: #bc6ec5;">[]</span><span style="color: #4f97d7;">)</span>    <span style="color: #4f97d7; font-weight: bold;">return</span> ans</pre></div></div></div></div></div><div id="outline-container-orgada5970" class="outline-2"><h2 id="orgada5970">参考</h2><div class="outline-text-2" id="text-orgada5970"><ol class="org-ol"><li><a href="https://segmentfault.com/a/1190000006121957" target="_blank" rel="noopener">(Leetcode) Backtracking回溯法(又称DFS,递归)全解</a></li><li><a href="https://leetcode.com/problems/combination-sum-ii/#/description" target="_blank" rel="noopener">leetcode Combination Sum II</a></li><li><a href="https://leetcode.com/problems/subsets-ii/#/description" target="_blank" rel="noopener">leetcode Subsets II</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        
&lt;div id=&quot;outline-container-orga9a49c9&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;orga9a49c9&quot;&gt;Backtracking 算法&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-org
      
    
    </summary>
    
      <category term="编程技巧" scheme="http://summerisgreen.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="编程技巧" scheme="http://summerisgreen.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
      <category term="算法" scheme="http://summerisgreen.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>巧用异或找出唯一出现奇数次的数字</title>
    <link href="http://summerisgreen.com/blog/2016-11-26-2016-11-26-%E5%B7%A7%E7%94%A8%E5%BC%82%E6%88%96%E6%89%BE%E5%87%BA%E5%94%AF%E4%B8%80%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>http://summerisgreen.com/blog/2016-11-26-2016-11-26-巧用异或找出唯一出现奇数次的数字.html</id>
    <published>2016-11-25T16:00:00.000Z</published>
    <updated>2019-03-14T23:44:29.660Z</updated>
    
    <content type="html"><![CDATA[<p>异或操作看似是数字逻辑的一个很简单的运算方法，但却具有一些很有用的特性，用好的话，对一些问题的解决可以起到四两拨千斤的效果。<a id="more"></a></p><div id="outline-container-org9c882f1" class="outline-2"><h2 id="org9c882f1">异或方法的基本原理</h2><div class="outline-text-2" id="text-org9c882f1"><p>在维基百科中异或是这样定义的：在数字逻辑中，逻辑算符互斥（exclusive or）是对两个运算元的一种逻辑分析类型。而基于二进制的计算机中的信息操作就可以看作是一堆进行数字逻辑操作的信息。这也是异或操作在计算机中的运算速度非常快的一个原因。</p><p>在数字逻辑中的运算方法有很多，而异或方法却能产生一些看似很奇妙的应用，这主要是因为它具有的数学上的一些特性：</p><ul class="org-ul"><li>交换率：A^B=B^A</li><li>结合率：A^B^C=A^(B^C)</li><li>归零率：A^A=0</li><li>自反：A^B^B=A</li></ul></div></div><div id="outline-container-orga6f27fa" class="outline-2"><h2 id="orga6f27fa">异或方法的一些简单的应用</h2><div class="outline-text-2" id="text-orga6f27fa"><p>知道了异或的数学性质之后，就可以发现下面两道题目使用异或操作非常简单了。</p></div><div id="outline-container-orga3e91a6" class="outline-3"><h3 id="orga3e91a6">快速比较两个数的值是否相等</h3><div class="outline-text-3" id="text-orga3e91a6"><p>在对时间和空间效率要求非常高的计算机底层编程中，经常会看到有汇编程序利用异或的归零率的特性，快速比较两个数的值是否相等。</p><div class="org-src-container"><pre class="src src-python">a^b == <span style="color: #a45bad;">0</span></pre></div></div></div><div id="outline-container-org0e3227e" class="outline-3"><h3 id="org0e3227e">不使用其他空间交换两个数的值</h3><div class="outline-text-3" id="text-org0e3227e"><p>应用异或操作的自反的性质，就可以在不使用额外空间的前提下交换两个数的值。</p><div class="org-src-container"><pre class="src src-python"><span style="color: #7590db;">a</span> = a^b<span style="color: #7590db;">b</span> = a^b<span style="color: #7590db;">a</span> = a^b</pre></div></div></div></div><div id="outline-container-org469a355" class="outline-2"><h2 id="org469a355">一些奇妙的应用</h2><div class="outline-text-2" id="text-org469a355"><p>除了在上面这些简单的问题上，可以使用异或操作的小技巧，并且使程序的时间和空间效率得到改善以外。异或方法还可以在一些较为复杂的问题上得到应用，比如下面将会介绍的用来在一组数中找出唯一一个只出现了奇数次的数字这一系列问题。</p></div><div id="outline-container-orgf4c7053" class="outline-3"><h3 id="orgf4c7053">校招之找出未打卡员工题</h3><div class="outline-text-3" id="text-orgf4c7053"><p>某互联网公司的一道很简单的校招笔试题目，使用异或可以很优雅地解决。</p><pre class="example">题目：输入两行数据，第一行为全部员工的 id，第二行为某一天打卡的员工 id，已知只有一个员工没有打卡，求出未打卡员工的 id。（员工 id 不重复，每行输入的 id 未排序）输入：1001 1003 1002 1005 10041002 1003 1001 1004输出：1005</pre></div></div><div id="outline-container-org19320ec" class="outline-3"><h3 id="org19320ec">leetcode之Single Number III</h3><div class="outline-text-3" id="text-org19320ec"><p>之前在leetcode上也看到过一个使用异或方法来解决将会变得非常简单的一道题目，其最终的时间和空间复杂度分别为O(n)和O(1)。</p><pre class="example">Given an array of numbers nums,in which exactly two elements appear only once andall the other elements appear exactly twice.Find the two elements that appear only once.</pre><p><!-- more --></p></div></div></div><div id="outline-container-orgd20fd20" class="outline-2"><h2 id="orgd20fd20">参考</h2><div class="outline-text-2" id="text-orgd20fd20"><p><a href="https://en.wikipedia.org/wiki/Exclusive_or" target="_blank" rel="noopener">Exclusive or</a></p><p><a href="https://www.lijinma.com/blog/2014/05/29/amazing-xor/" target="_blank" rel="noopener">感受异或的神奇</a></p><p><a href="http://www.alijava.com/campus-interview/" target="_blank" rel="noopener">2017互联网校招的一些面试题</a></p><p><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">Single Number III</a></p></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;
异或操作看似是数字逻辑的一个很简单的运算方法，
但却具有一些很有用的特性，用好的话，对一些问题的解决可以起到四两拨千斤的效果。
    
    </summary>
    
      <category term="编程技巧" scheme="http://summerisgreen.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="编程技巧" scheme="http://summerisgreen.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
      <category term="算法" scheme="http://summerisgreen.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo和emacs-Org来写博客</title>
    <link href="http://summerisgreen.com/blog/2016-09-30-2016-09-30-%E4%BD%BF%E7%94%A8hexo%E5%92%8Cemacs-org%E6%9D%A5%E5%86%99%E5%8D%9A%E5%AE%A2.html"/>
    <id>http://summerisgreen.com/blog/2016-09-30-2016-09-30-使用hexo和emacs-org来写博客.html</id>
    <published>2016-09-29T16:00:00.000Z</published>
    <updated>2019-12-01T15:14:27.896Z</updated>
    
    <content type="html"><![CDATA[<div id="outline-container-org149521e" class="outline-2"><h2 id="org149521e">使用org-mode来写博客</h2><div class="outline-text-2" id="text-org149521e"><p>最近闲着部署了一个静态博客，开启了自己的博客生涯，采用的方案是目前最流行的 Github Pages + Hexo 。使用 Hexo 博客框架可以方便快捷地完成部署，发布的功能，不过其只默认支持解析 markdown 格式的文章。作为一个 emacs 用户，习惯于使用功能变态级强大的 org-mode 来写文档，自然也想要让自己的博客能够直接支持解析 org 格式文件。对于这项任务，google了下发现已经有人做了 org-octopress 这个插件来支持 org-mode 写博客，emacs 丰富的开源插件果然是很强大。</p></div><div id="outline-container-org2c3e689" class="outline-3"><h3 id="org2c3e689">配置org-octopress</h3><div class="outline-text-3" id="text-org2c3e689"><p>为了配置该功能，首先从Melpa软件仓库中安装org-octopress，并添加下面的代码设置你的文章发布功能。</p><div class="org-src-container"><pre class="src src-elisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">require</span> '<span style="color: #a45bad;">org-octopress</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> org-octopress-directory-top       <span style="color: #2d9574;">"~/YourBlogDirectory"</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> org-octopress-directory-posts     <span style="color: #2d9574;">"~/YourBlogDirectory/source/_posts"</span><span style="color: #4f97d7;">)</span> <span style="color: #2aa1ae; background-color: #292e34;">;</span><span style="color: #2aa1ae; background-color: #292e34;">&#25991;&#31456;&#21457;&#24067;&#30446;&#24405;</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> org-octopress-directory-org-top   <span style="color: #2d9574;">"~/YourBlogDirectory"</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> org-octopress-directory-org-posts <span style="color: #2d9574;">"~/YourBlogDirectory/blog"</span><span style="color: #4f97d7;">)</span> <span style="color: #2aa1ae; background-color: #292e34;">;</span><span style="color: #2aa1ae; background-color: #292e34;">org&#25991;&#31456;&#30446;&#24405;</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> org-octopress-setup-file          <span style="color: #2d9574;">"~/YourBlogDirectory/setupfile.org"</span><span style="color: #4f97d7;">)</span></pre></div><p>其中的具体目录可以依据自己的实际情况进行修改，在这里 top 指定的是博客的根目录；posts 为发布成 html 格式的文章所在的目录；org-posts 为你使用 org 模式写的博客所在的目录；org-top 为 org 博客的上一级别目录。</p><p>完成了之前的设定之后，你需要修改博客目录下的 _config.yml，以便适配 org-octopress 解析成的 html 博客文件：</p><pre class="example">permalink: /blog/:year-:month-:day-:title.html</pre><p>接下来，你就可以使用 org-octopress 功能，此时会进入一个博客文章管理的 buffer，在这里面可以轻松地添加、修改或删除博客文章。</p><p>最后，当你写完博客以后，org-export-dispatch 中的 Publish 选项中来选择导出当前的博客文章或者整个 octopress 工程。如果你想要预览你的文章的效果，你可以使用 prodigy 来快速查看，具体配置及使用可见 <a href="#org49507b8">下一章节</a>。</p></div></div><div id="outline-container-orgf7b70fb" class="outline-3"><h3 id="orgf7b70fb">org博客中引用图片</h3><div class="outline-text-3" id="text-orgf7b70fb"><p>为了避免在 org-mode 输出为 html 的过程中，图片引用路径产生问题，需要在 emacs 的配置文件中加入下面的代码来在 org-mode 中注册一种新的图片引用格式。</p><div class="org-src-container"><pre class="src src-elisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">require</span> '<span style="color: #a45bad;">ox-publish</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defun</span> <span style="color: #bc6ec5; font-weight: bold;">org-custom-link-img-follow</span> <span style="color: #bc6ec5;">(</span>path<span style="color: #bc6ec5;">)</span>  <span style="color: #bc6ec5;">(</span>org-open-file-with-emacs   <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"../source/img/%s"</span> path<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>   <span style="color: #2aa1ae; background-color: #292e34;">;</span><span style="color: #2aa1ae; background-color: #292e34;">the path of the image in local dic</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defun</span> <span style="color: #bc6ec5; font-weight: bold;">org-custom-link-img-export</span> <span style="color: #bc6ec5;">(</span>path desc format<span style="color: #bc6ec5;">)</span>  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">cond</span>   <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>eq format 'html<span style="color: #67b11d;">)</span>    <span style="color: #67b11d;">(</span>format <span style="color: #2d9574;">"&lt;img src=\"/img/%s\" alt=\"%s\"/&gt;"</span> path desc<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> <span style="color: #2aa1ae; background-color: #292e34;">;</span><span style="color: #2aa1ae; background-color: #292e34;">the path of the image in webserver</span><span style="color: #4f97d7;">(</span>org-add-link-type <span style="color: #2d9574;">"img"</span> 'org-custom-link-img-follow 'org-custom-link-img-export<span style="color: #4f97d7;">)</span></pre></div><p>这两个路径所代表的图片存储位置分别是从 org 格式的文章所在的目录和 web 服务器的角度来看的。如果使用该种配置方式，为了方便引用，建议将图片保存在 source 文件夹中。</p></div></div></div><div id="outline-container-org6a6288d" class="outline-2"><h2 id="org6a6288d">在emacs中启动服务器和部署博客</h2><div class="outline-text-2" id="text-org6a6288d"><p><a id="org49507b8"></a>在 emacs 中启动外部服务的任务可以通过 Prodigy 这个插件提供的功能完成。在 Melpa 中安装了该插件之后，添加下面的代码到你的配置文件后，就可以使用 prodigy 在浏览器本地调试(hexo server默认指定4000端口)博客(Hexo Server）以及一键完成博客部署（Hexo Deploy）。</p><div class="org-src-container"><pre class="src src-elisp"><span style="color: #4f97d7;">(</span>prodigy-define-service <span style="color: #4f97d7;">:name</span> <span style="color: #2d9574;">"Hexo Server"</span> <span style="color: #4f97d7;">:command</span> <span style="color: #2d9574;">"hexo"</span> <span style="color: #4f97d7;">:args</span> '<span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">"server"</span><span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">:cwd</span> <span style="color: #2d9574;">"~/YourBlogDirectory"</span> <span style="color: #4f97d7;">:tags</span> '<span style="color: #bc6ec5;">(</span>hexo server<span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">:kill-signal</span> 'sigkill <span style="color: #4f97d7;">:kill-process-buffer-on-stop</span> t<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">(</span>prodigy-define-service <span style="color: #4f97d7;">:name</span> <span style="color: #2d9574;">"Hexo Deploy"</span> <span style="color: #4f97d7;">:command</span> <span style="color: #2d9574;">"hexo"</span> <span style="color: #4f97d7;">:args</span> '<span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">"deploy"</span> <span style="color: #2d9574;">"--generate"</span><span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">:cwd</span> <span style="color: #2d9574;">"~/YourBlogDirectory"</span> <span style="color: #4f97d7;">:tags</span> '<span style="color: #bc6ec5;">(</span>hexo deploy<span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">:kill-signal</span> 'sigkill <span style="color: #4f97d7;">:kill-process-buffer-on-stop</span> t<span style="color: #4f97d7;">)</span></pre></div><p>在 prodigy 模式下你可以通过s来启动所选服务，使用S来停止对应的服务，该模式的详细的快捷键定义在 prodigy-mode-map 中，不过知道这两个就应该够用了。</p></div></div><div id="outline-container-org890cda8" class="outline-2"><h2 id="org890cda8">参考</h2><div class="outline-text-2" id="text-org890cda8"><p>1.<a href="https://zilongshanren.com/blog/2015-07-19-add-org-mode-support.html" target="_blank" rel="noopener">使用 Org-mode 来写博客</a></p><p>2.<a href="https://zilongshanren.com/blog/2015-08-02-migrate-blog-to-hexo.html" target="_blank" rel="noopener">迁移博客到 Hexo</a></p><p>3.<a href="http://stackoverflow.com/questions/14684263/how-to-org-mode-image-absolute-path-of-export-html" target="_blank" rel="noopener">how to org mode image absolute path of export html</a></p></div></div>]]></content>
    
    <summary type="html">
    
      
      
        

&lt;div id=&quot;outline-container-org149521e&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;org149521e&quot;&gt;使用org-mode来写博客&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-org
      
    
    </summary>
    
      <category term="emacs" scheme="http://summerisgreen.com/categories/emacs/"/>
    
    
      <category term="emacs" scheme="http://summerisgreen.com/tags/emacs/"/>
    
      <category term="blog" scheme="http://summerisgreen.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>arch下使用aria2下载资源</title>
    <link href="http://summerisgreen.com/blog/2016-09-25-2016-09-25-arch%E4%B8%8B%E4%BD%BF%E7%94%A8aria2%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90.html"/>
    <id>http://summerisgreen.com/blog/2016-09-25-2016-09-25-arch下使用aria2下载资源.html</id>
    <published>2016-09-24T16:00:00.000Z</published>
    <updated>2019-03-14T23:44:25.400Z</updated>
    
    <content type="html"><![CDATA[<p>linux 中拥有大量的下载工具，不过没有一个像迅雷那样在windows中文世界中占有统治地位。对于一般 linux 用户常用的下载工具，比如gnome和kde等桌面环境中自带的 utorrent 或 ktorrent ，自身下载速度不快，还有着占用内存资源多，支持下载协议有限的缺点。对于追求简洁高效的系统的人来说，自然是难以接受的。</p><p>而 aria2 作为一个轻型的，多协议支持的下载工具，而且还拥有很多实用的扩展工具，可以说是 linux 下一个杀手级的下载工具。</p><p>不过 aria2 不像一般的下载工具那样开箱即用；它的安装和配置自定义的程度高，并且是需要花点功夫来折腾下的，可以说是一款偏 geek 的下载工具。</p><div id="outline-container-org70c8e5f" class="outline-2"><h2 id="org70c8e5f">aria2是什么？</h2><div class="outline-text-2" id="text-org70c8e5f"><p>aria2是一款轻量级的、支持多协议的和多个下载源的下载工具，它能够支持HTTP/HTTPS，FTP，SFTP，BitTorrent以及Metalink这么多协议的下载。具体介绍可参照<a href="https://aria2.github.io/" target="_blank" rel="noopener">aria2官网</a>。</p><p>除了丰富的协议支持，它还有两个非常惊艳的优点：一个是轻量级：占用内存空间十分少，通常只占用4-9MB。另一个优势就是支持RPC界面远程控制，可以很方便的对被配置为服务器的主机进行下载管理。可以说对于linux主机来说是一款绝佳的下载工具。</p><p>用了一段时间后，还是非常满意这个小巧易用的下载工具；唯一的一点遗憾就是不能下载迅雷链接，每次搜老电影都只能找到迅雷链接的我真是快哭了。</p><p>体会到了aria2的强大了之后，就来看看正确安装并配置aria2。</p></div></div><div id="outline-container-orge4d18ce" class="outline-2"><h2 id="orge4d18ce">aria2的安装及配置</h2><div class="outline-text-2" id="text-orge4d18ce"></div><div id="outline-container-org8d89a63" class="outline-3"><h3 id="org8d89a63">安装aria2</h3><div class="outline-text-3" id="text-org8d89a63"><p>aria2 作为 linux 下常用的下载工具，一般的发行版仓库中都会有该软件的包，可以使用包管理系统直接安装。比如在 archlinux 中，可以使用如下的命令直接安装：</p><div class="org-src-container"><pre class="src src-bash">$ sudo pacman -S aria2</pre></div><p>此时已经可以直接通过命令行运行aria2来进行下载，不过并不推荐。因为这样每次都需要使用命令行参数来对断点续传或者速度限制等功能进行说明，并且下载管理也是不太方便。</p><p>这里推荐使用配置文件启动aria2服务，再通过web图形前端进行管理的优秀实践。</p></div></div><div id="outline-container-org12a7f58" class="outline-3"><h3 id="org12a7f58">配置aria2</h3><div class="outline-text-3" id="text-org12a7f58"><p>配置文件主要用于你的RPC信息以及下载相关的速度，进度以及磁盘等信息的设置。具体可参考<a href="https://github.com/green-93-nope/myConfiguration/blob/master/aria2/aria2.conf" target="_blank" rel="noopener">我的配置</a>。该配置文件一般放在$HOME/.aria2/aria2.conf中。</p><p>除了这个配置文件之外你还需要创建一个session.lock文件，用来管理下载历史。该文件所放置的位置和配置文件中的input-file和save-session对应即可。</p><p>配置完成后运行下面的命令，即可启动aria2到后台。-D表示运行程序到后台。假如你不确定自己的配置是否正确，你可以命令后不加-D来观察输出是否正确。</p><div class="org-src-container"><pre class="src src-bash">$ aria2c --conf-path=&lt;PATH&gt; -D</pre></div><p>如果你和我一样厌烦了每次都要输入这一大堆命令你可以使用alias别名或者写一个简单的脚本来简化你的输入。</p></div></div><div id="outline-container-orgce66725" class="outline-3"><h3 id="orgce66725">图形前端</h3><div class="outline-text-3" id="text-orgce66725"><p>aria2本身并没有图形界面，不过可以通过一些开源的web图形前端来进行管理，也是非常方便的。</p><p>比较有名并且好用的图形前端主要有<a href="https://github.com/binux/yaaw" target="_blank" rel="noopener">YAAW</a> 和<a href="https://github.com/ziahamza/webui-aria2" target="_blank" rel="noopener">webui-aria2</a>。我使用的是第二个。</p><p>这两款应用都已经在arch的AUR仓库中了，使用yaourt可以很方便的安装。比如：</p><div class="org-src-container"><pre class="src src-bash">$ sudo yaourt -S webui-aria2</pre></div><p>安装完成后在浏览器中打开<a href="http://ziahamza.github.io/webui-aria2/" target="_blank" rel="noopener">管理页面</a> 即可进行管理。</p></div></div><div id="outline-container-orge595a88" class="outline-3"><h3 id="orge595a88">更多</h3><div class="outline-text-3" id="text-orge595a88"><p>对于中国用户还有个福音，那就是有人已经开发出了浏览器插件来支持直接下载百度云和迅雷离线的内容，是不是瞬间感觉到逼格慢慢。</p><p>1.下载百度云链接<a href="https://github.com/acgotaku/BaiduExporter" target="_blank" rel="noopener">BaiduExporter</a>。</p><p>2.下载迅雷离线内容<a href="http://binux.github.io/ThunderLixianExporter/" target="_blank" rel="noopener">ThunderLixianExporter</a></p></div></div></div><div id="outline-container-org11a3832" class="outline-2"><h2 id="org11a3832">参考</h2><div class="outline-text-2" id="text-org11a3832"><p>1.<a href="http://blog.binux.me/2012/12/aria2-examples/" target="_blank" rel="noopener">aria2配置示例</a></p><p>2.<a href="http://moflying.com/2016/06/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8aria2%E5%8F%8Awebui-aria2%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E4%BA%91%E8%B5%84%E6%BA%90/" target="_blank" rel="noopener">如何使用aria2及webui-aria2下载百度云资源</a></p><p>3.<a href="https://wiki.archlinux.org/index.php/Aria2" target="_blank" rel="noopener">aria2-archwiki</a></p></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;
linux 中拥有大量的下载工具，不过没有一个像迅雷那样在windows中文世界中占有统治地位。
对于一般 linux 用户常用的下载工具，比如gnome和kde等桌面环境中自带的 utorrent 或 ktorrent ，
自身下载速度不快，还有着占用内存资源多，支持下
      
    
    </summary>
    
      <category term="archlinux" scheme="http://summerisgreen.com/categories/archlinux/"/>
    
    
      <category term="archlinux" scheme="http://summerisgreen.com/tags/archlinux/"/>
    
  </entry>
  
  <entry>
    <title>配置支持中文输入的emacsclient</title>
    <link href="http://summerisgreen.com/blog/2016-09-24-2016-09-24-%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E7%9A%84emacsclient.html"/>
    <id>http://summerisgreen.com/blog/2016-09-24-2016-09-24-配置支持中文输入的emacsclient.html</id>
    <published>2016-09-23T16:00:00.000Z</published>
    <updated>2019-03-14T23:44:25.100Z</updated>
    
    <content type="html"><![CDATA[<p>因为习惯了 emacs 的高效编辑，所以一直想要将arch的默认编辑器设置为emacs。然而 emacs 每次启动都要加载大量的配置文件，缓慢的打开速度使它很难作为快速的编辑工具来使用。</p><p>最近发现了一个非常不错的通过使用emacsclient来快速启动新的emacs窗口的解决方案。并且通过一些额外的设置可以很好地支持中文输入。</p><div id="outline-container-orga6d1c8e" class="outline-2"><h2 id="orga6d1c8e">emacsclient</h2><div class="outline-text-2" id="text-orga6d1c8e"><p>emacsclient 的原理十分简单，就是预先启动一个emacs作为守护进程，每次想要进行一个新的编辑时，就打开一个窗口并链接到守护进程。这样就免去了最耗时的每次启动时的加载配置，十分快速的同时还拥有你自定义的配置。</p><p>对于emacs英文用户来说，在终端下直接运行如下命令即可打开终端下的或者带有图形界面的 emacs 客户端。</p><div class="org-src-container"><pre class="src src-bash">$ emacsclient -t -a <span style="color: #2d9574;">""</span>  <span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#32456;&#31471;&#20013;&#24320;&#21551;emacs</span>$ emacsclient -nc -a <span style="color: #2d9574;">""</span>  <span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">&#21551;&#21160;emacs&#22270;&#24418;&#30028;&#38754;</span></pre></div><p>其中-a ""参数表示，当第一次运行这个命令时，它会把emacs当作守护进程来启动，之后就会一直驻留在后台。等到再次使用 emacsclient 时，就会把新建的窗口链接到该守护程序实现快速启动。</p><p>但是对于中文用户来说，进入后就会发现会遇到中文乱码，fcitx 输入法无法被激活的问题。不过可以通过下面这些额外的设置来解决这两个问题。</p></div></div><div id="outline-container-orge27db32" class="outline-2"><h2 id="orge27db32">新窗口中支持中文字体</h2><div class="outline-text-2" id="text-orge27db32"><p>因为在 emacs 中关于界面和字体的设置只有在创建新的frame时才有效，而启动服务器的时候并没有创建frame。所以要想在 emacsclient 中正确的显示中文字体必须要添加一些额外的设置。</p><div class="org-src-container"><pre class="src src-emacs">(setq window-system-default-frame-alist      '(        ;; if frame created on x display        (x         (menu-bar-lines . 1)         (tool-bar-lines . nil)         ;; mouse         (mouse-wheel-mode . 1)         (mouse-wheel-follow-mouse . t)         (mouse-avoidance-mode . 'exile)         ;; face 具体可以更换为系统支持的中文字体         (font . "WenQuanYi Micro Hei Mono 12")         )        ;; if on term        (nil         (menu-bar-lines . 0) (tool-bar-lines . 0)         ;; (background-color . "black")         ;; (foreground-color . "white")         )        )      )</pre></div><p>对于 spacemacs 用户来说，默认的配置已经解决了新窗口的字体问题，所以不需要再进行额外的设置了。</p></div></div><div id="outline-container-org463cc01" class="outline-2"><h2 id="org463cc01">用户环境变量配置</h2><div class="outline-text-2" id="text-org463cc01"><p>一般言系统环境中LC_CTYPE默认设置为英文，此时在Emacs上可能无法使用输入法。为了能够支持fcitx的输入，在启动Emacs时需要指定LC_CTYPE为zh_CN.UTF-8。使用下面的命令进行，就可以使用支持fcitx中文输入的emacs:</p><div class="org-src-container"><pre class="src src-bash">$ <span style="color: #7590db;">LC_CTYPE</span>=zh_CN.UTF-8 emacs</pre></div><p>当然你还可以利用alias别名命令来简化命令的输入。比如我就在自己的个人环境信息配置文件(.profile或者.bashrc)中加入如下信息。</p><div class="org-src-container"><pre class="src src-bash"><span style="color: #4f97d7;">alias</span> <span style="color: #7590db;">emacs</span>=<span style="color: #2d9574;">'LC_CTYPE=zh_CN.UTF-8 emacs'</span><span style="color: #4f97d7;">alias</span> <span style="color: #7590db;">em</span>=<span style="color: #2d9574;">'emacsclient -t -a ""'</span>  <span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#32456;&#31471;&#20013;&#24320;&#21551;emacs</span><span style="color: #4f97d7;">alias</span> <span style="color: #7590db;">emc</span>=<span style="color: #2d9574;">'LC_CTYPE=zh_CN.UTF-8 emacsclient -nc -a ""'</span>  <span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">&#21551;&#21160;emacs&#22270;&#24418;&#30028;&#38754;</span><span style="color: #4f97d7;">export</span> <span style="color: #7590db;">EDITOR</span>=<span style="color: #2d9574;">"$(if [[ -n $DISPLAY ]]; then echo 'LC_CTYPE=zh_CN.UTF-8 emacsclient -a ""'; else echo 'vi'; fi)"</span></pre></div><p>之后直接在终端下输入emc，就可以快速启动emacsclient的图形界面进行编辑了，就是这么简单哈。</p></div></div><div id="outline-container-org600526f" class="outline-2"><h2 id="org600526f">参考</h2><div class="outline-text-2" id="text-org600526f"><p>1.<a href="https://wiki.archlinux.org/index.php/Emacs_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Emacs&#x2013;archwiki</a></p><p>2.<a href="http://emacser.com/daemon.htm" target="_blank" rel="noopener">使用emacs daemon</a></p><p>3.<a href="https://wiki.archlinux.org/index.php/Fcitx_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Emacs_.E6.97.A0.E6.B3.95.E4.BD.BF.E7.94.A8.E8.BE.93.E5.85.A5.E6.B3.95" target="_blank" rel="noopener">fcitx&#x2013;archlinux</a></p></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;
因为习惯了 emacs 的高效编辑，所以一直想要将arch的默认编辑器设置为emacs。
然而 emacs 每次启动都要加载大量的配置文件，缓慢的打开速度使它很难作为快速的编辑工具来使用。
&lt;/p&gt;

&lt;p&gt;
最近发现了一个非常不错的通过使用emacsclient来快速启
      
    
    </summary>
    
      <category term="emacs" scheme="http://summerisgreen.com/categories/emacs/"/>
    
    
      <category term="emacs" scheme="http://summerisgreen.com/tags/emacs/"/>
    
  </entry>
  
  <entry>
    <title>转投Archlinux</title>
    <link href="http://summerisgreen.com/blog/2016-09-06-2016-09-06-%E8%BD%AC%E6%8A%95archlinux.html"/>
    <id>http://summerisgreen.com/blog/2016-09-06-2016-09-06-转投archlinux.html</id>
    <published>2016-09-05T16:00:00.000Z</published>
    <updated>2019-03-14T23:44:29.023Z</updated>
    
    <content type="html"><![CDATA[<div id="outline-container-org8dc22b0" class="outline-2"><h2 id="org8dc22b0">为什么选择archlinux?</h2><div class="outline-text-2" id="text-org8dc22b0"><p>在使用 archlinux 之前，我还使用过 opensuse 和 ubuntu 这两款普及率比较高的 linux 发行版。</p><p>来自德国的linux发行版opensuse，采用了KDE的桌面环境，桌面简洁华丽, 还配有强大的包管理界面工具zypper。但却有着一些让你不得不放弃的缺点:</p><ul class="org-ul"><li>由于墙的封锁， 而opensuse国内的镜像源也不多，每次更新都会被它的慢性子给急死。</li><li>opensuse的包管理非常严格, 导致了很多软件包官方都不予支持。但就算这样，python-matplotlib这个科学计算必备的包竟然还出现了打包错误。。。</li><li>opensuse采用的kde桌面虽然是非常华丽， 但是bug率也是让人无法忍受, 时常会出现桌面崩溃的情况， 这对于作为日常工作使用的系统来说可以说是致命的缺陷。也正因此我继而选择改用ubuntu。</li></ul><p>ubuntu作为linux世界最为人熟知的发行版了， 它拥有开箱即用，丰富的软件支持等相当给力的优点。这些优点从win平台转来的新手十分容易上手，而且在日常的使用中也是让人非常省心的。作为一个面向新手的发行版，在易用性上可以说是极其完美的。这也造成了后来我觉得archlinux安装过于麻烦而迟迟不愿尝试。不过这个开箱即用的设计理念也却对想要尝试自己DRY的geek来说带来很多的问题:</p><ul class="org-ul"><li>作为一个想要提高生产力的程序员，如果你想要使用一些平铺式的窗口管理器，你会发现自己要解决大量的和ubuntu unity之间的冲突。</li><li>如果你又碰巧是emacs用户, 你会发现快捷绑定中又存在这大量的冲突，而其中又有一些通过搜索引擎也找不到有用的解决方案。</li></ul><p>在成长为一个实用主义的程序员的过程中，我发现自己需要的是一个简单易用，而且又能很好地支持全键盘操作这种高生产力操作方式的操作系统。经过在google和知乎的一番调研，我最终选择了 archlinux。它除了满足我的需求之外，还有着以下几个优点：</p></div><div id="outline-container-org3e82e27" class="outline-3"><h3 id="org3e82e27">简洁</h3><div class="outline-text-3" id="text-org3e82e27"><p>arch的哲学是Keep It Simple, Stupid。所以在初始安装时它只会安装一个无图像界面的基本系统。这也给arch用户极大的自由度以根据自己的考量或喜爱来DRY出自己的系统。</p></div></div><div id="outline-container-orgbfc2af1" class="outline-3"><h3 id="orgbfc2af1">包管理</h3><div class="outline-text-3" id="text-orgbfc2af1"><p>arch有着极其强大的包管理工具pacman，它的输出简单易懂而且十分规范，非常方便后期的解析。如果你仔细看过pacman的官方wiki，你就会发现如此惊艳的获取来自官方源的软件包并重新安装的命令：</p><pre class="example">comm -23 &lt;(pacman -Qeq|sort) &lt;(pacman -Qmq|sort) &gt; pkglistsudo pacman -S $(&lt; pkglist)</pre><p>arch的官方软件仓库中的软件已经足够丰富了，具有一定用户量的软件都会有。如果你要用的确实是一些非常冷门的软件而在官方仓库中无法找到，那就试一下AUR仓库，你有很大的可能会满意而归。这是一个由用户者们自行管理的软件仓库，拥有非常丰富的软件资源，而且它的软件包管理也极其方便有 yaourt这种和pacman命令参数兼容的工具来提供管理服务。</p><p>arch的包管理还有一个很强大的优势就是镜像源多，更新速度极其快。</p></div></div><div id="outline-container-org5b69f09" class="outline-3"><h3 id="org5b69f09">Wiki</h3><div class="outline-text-3" id="text-org5b69f09"><p>arch还有一个对其他发行版的巨大优势就是极其非常完善的wiki，从系统的安装到应用的使用配置都有大量的wiki来进行指导，这也是为什么archlinux并不容易上手，但却有着庞大用户量的一个原因吧。</p></div></div></div><div id="outline-container-orgcc6c0b8" class="outline-2"><h2 id="orgcc6c0b8">arch之旅</h2><div class="outline-text-2" id="text-orgcc6c0b8"><p>说到这，可能你对arch会开始感兴趣。不过如果要你使用它，你还是有一些抵触，因为你可能听说：</p><p>Q1: archlinux很难安装， 不是那种很爱折腾的人最好不要使用。</p><p>A1: archlinux的安装虽然不像ubuntu那样傻瓜式的简单， 但只要你按照官方的<a href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener">安装wiki</a> 的步骤一步步来，也并不难，只是需要点耐心了。当然如果你是和我一样的windows双系统使用者, 你还需要在安装启动引导前安装os-prober即可。</p><p>Q2: archlinux是滚动升级版本并且很容易滚挂。</p><p>A2: archlinux是滚动更新的， 如果用户平时不注意维护是很容易滚挂的，但是如果你是一个有心人，平时注意定期<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">维护</a> 和<a href="https://wiki.archlinux.org/index.php/Full_system_backup_with_rsync_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">备份</a> ，并且在你每次更新系统前留意<a href="https://www.archlinux.org/feeds/news/" target="_blank" rel="noopener">archlinux新闻</a> 的话, 并不需要担心滚挂的问题。网上也有很多人，安装了一次后可以用上很多年，比ubuntu LTS版用的还长。</p></div></div>]]></content>
    
    <summary type="html">
    
      
      
        
&lt;div id=&quot;outline-container-org8dc22b0&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;org8dc22b0&quot;&gt;为什么选择archlinux?&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-org
      
    
    </summary>
    
      <category term="archlinux" scheme="http://summerisgreen.com/categories/archlinux/"/>
    
    
      <category term="archlinux" scheme="http://summerisgreen.com/tags/archlinux/"/>
    
  </entry>
  
</feed>
